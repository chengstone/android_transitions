<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Reveal.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.transition</a> &gt; <span class="el_source">Reveal.java</span></div><h1>Reveal.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.transition;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.TimeInterpolator;
import android.annotation.SuppressLint;
import android.content.Context;
import android.content.res.TypedArray;
import android.os.Build;
import android.support.annotation.FloatRange;
import android.support.annotation.IntDef;
import android.support.annotation.IntRange;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RequiresApi;
import android.support.annotation.Size;
import android.support.annotation.UiThread;
import android.support.annotation.VisibleForTesting;
import android.support.v4.view.animation.FastOutSlowInInterpolator;
import android.transition.TransitionValues;
import android.transition.Visibility;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.view.ViewAnimationUtils;
import android.view.ViewGroup;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import universum.studios.android.transition.util.AnimatorWrapper;

/**
 * A {@link Visibility} transition implementation that tracks changes to the visibility of target
 * views in the start and end scenes and reveals or conceals views in the scene. Visibility is
 * determined by both the {@link View#setVisibility(int)} state of the view as well as whether it
 * is parented in the current view hierarchy. Disappearing Views are limited as described in
 * {@link Visibility#onDisappear(android.view.ViewGroup, TransitionValues, int, TransitionValues, int)}.
 * &lt;p&gt;
 * A Reveal transition uses {@link ViewAnimationUtils#createCircularReveal(View, int, int, float, float)}
 * to create a circular reveal/conceal animator that is used to animate its target views. A center
 * coordinates of revealing/concealing circle can be specified via {@link #setCenterX(Float)} and
 * {@link #setCenterY(Float)} or by using fractions via {@link #setCenterXFraction(float)} and
 * {@link #setCenterYFraction(float)}. If specifying a gravity for the center of the animating circle
 * is enough, the desired gravity flags may be specified via {@link #setCenterGravity(Integer)}.
 * &lt;p&gt;
 * Reveal transition can be described in a resource file by using the {@code transition} tag with
 * {@code class} attribute set to {@code universum.studios.android.transition.Reveal}, along with
 * Xml attributes referenced below.
 *
 * &lt;h3&gt;XML attributes&lt;/h3&gt;
 * {@link R.styleable#Ui_Transition_Reveal Reveal Attributes}
 *
 * @author Martin Albedinsky
 */
@RequiresApi(Build.VERSION_CODES.LOLLIPOP)
public class Reveal extends Visibility {

	/*
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;Reveal&quot;;

	/**
	 * Mode to indicate that Reveal transition should play &lt;b&gt;reveal&lt;/b&gt; animation, that is to
	 * 'upscale' the animating circle of an animating view from its initial size to a larger one.
	 * &lt;p&gt;
	 * This mode can be used as well for &lt;b&gt;appearing&lt;/b&gt; targets as for &lt;b&gt;disappearing&lt;/b&gt; ones.
	 */
	public static final int REVEAL = MODE_IN;

	/**
	 * Mode to indicate that Reveal transition should play &lt;b&gt;conceal&lt;/b&gt; animation, that is to
	 * 'downscale' the animating circle of an animating view from its initial size to a smaller one.
	 * &lt;p&gt;
	 * This mode can be used as well for &lt;b&gt;disappearing&lt;/b&gt; targets as for &lt;b&gt;appearing&lt;/b&gt; ones.
	 */
	public static final int CONCEAL = MODE_OUT;

	/**
	 * Defines an annotation for determining set of allowed modes for Reveal transition.
	 */
	@Retention(RetentionPolicy.SOURCE)
	@IntDef({REVEAL, CONCEAL})
	public @interface RevealMode {
	}

	/**
	 * Default value for center fraction.
	 */
	private static final float CENTER_FRACTION = 0.5f;

	/*
	 * Interface ===================================================================================
	 */

	/*
	 * Static members ==============================================================================
	 */

	/**
	 * Default interpolator attached to {@link Animator} created via {@link #createAnimator(View, int, int, float, float)}.
	 */
<span class="fc" id="L126">	public static final TimeInterpolator INTERPOLATOR = new FastOutSlowInInterpolator();</span>

	/*
	 * Members =====================================================================================
	 */

	/**
	 * Object that holds all necessary properties for the reveal transition for the currently
	 * transitioning view.
	 */
<span class="fc" id="L136">	private final Info mInfo = new Info();</span>

	/**
	 * Mode determining whether we will run &lt;b&gt;reveal&lt;/b&gt; or &lt;b&gt;conceal&lt;/b&gt; animation.
	 * Either {@link #REVEAL} or {@link #CONCEAL}.
	 */
<span class="fc" id="L142">	private int mMode = REVEAL;</span>

	/**
	 * X coordinate for center of the reveal/conceal animation. If {@code null}, {@link #mCenterXFraction}
	 * should be used to calculate this coordinate.
	 */
	private Float mCenterX;

	/**
	 * Y coordinate for center of the reveal/conceal animation. If {@code null}, {@link #mCenterYFraction}
	 * should be used to calculate this coordinate.
	 */
	private Float mCenterY;

	/**
	 * Fraction from the {@code [0.0, 1.0]} range that can be used to calculate X coordinate for center
	 * of the reveal/conceal animation if {@link #mCenterX} coordinate has not been specified.
	 */
<span class="fc" id="L160">	private float mCenterXFraction = CENTER_FRACTION;</span>

	/**
	 * Fraction from the {@code [0.0, 1.0]} range that can be used to calculate Y coordinate for center
	 * of the reveal/conceal animation if {@link #mCenterY} coordinate has not been specified.
	 */
<span class="fc" id="L166">	private float mCenterYFraction = CENTER_FRACTION;</span>

	/**
	 * Gravity flags used to resolve center coordinates for the reveal/conceal animation.
	 * If {@code null}, values specified for {@link #mCenterX} and {@link #mCenterY} should be used
	 * as center coordinates.
	 */
	private Integer mCenterGravity;

	/**
	 * Value in pixels by which to offset {@link #mCenterY} vertically.
	 */
	private int mCenterVerticalOffset;

	/**
	 * Value in pixels by which to offset {@link #mCenterX} horizontally.
	 */
	private int mCenterHorizontalOffset;

	/**
	 * Start radius for circle of the reveal/conceal animation.
	 */
	private Float mStartRadius;

	/**
	 * End radius for circle of the reveal/conceal animation.
	 */
	private Float mEndRadius;

	/**
	 * Visibility flag set to a revealing view whenever the reveal animation starts.
	 */
<span class="fc" id="L198">	private int mStartVisibility = View.VISIBLE;</span>

	/**
	 * Visibility flag set to a revealing view whenever the reveal animation ends.
	 */
<span class="fc" id="L203">	private int mEndVisibility = View.VISIBLE;</span>

	/**
	 * Visibility flag set to a revealing view whenever {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}
	 * is invoked.
	 */
<span class="fc" id="L209">	private int mAppearVisibility = View.VISIBLE;</span>

	/**
	 * Visibility flag set to a revealing view whenever {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
	 * is invoked.
	 */
<span class="fc" id="L215">	private int mDisappearVisibility = View.VISIBLE;</span>

	/*
	 * Constructors ================================================================================
	 */

	/**
	 * Same as {@link #Reveal(int)} with {@link #REVEAL} mode.
	 */
	public Reveal() {
<span class="fc" id="L225">		this(REVEAL);</span>
<span class="fc" id="L226">	}</span>

	/**
	 * Creates a new instance of Reveal transition with the specified &lt;var&gt;mode&lt;/var&gt;.
	 *
	 * @param mode One of {@link #REVEAL} or {@link #CONCEAL}.
	 */
	public Reveal(@RevealMode final int mode) {
<span class="fc" id="L234">		super();</span>
<span class="fc" id="L235">		setMode(mode);</span>
<span class="fc" id="L236">	}</span>

	/**
	 * Creates a new instance of Reveal transition with animation property values set from the
	 * specified &lt;var&gt;attrs&lt;/var&gt;.
	 *
	 * @param context Context used to obtain values from the specified &lt;var&gt;attrs&lt;/var&gt;.
	 * @param attrs   Set of attributes from which to obtain property values for the reveal animation.
	 */
	@SuppressWarnings(&quot;ResourceType&quot;)
	public Reveal(@NonNull final Context context, @Nullable final AttributeSet attrs) {
<span class="fc" id="L247">		super(context, attrs);</span>
<span class="fc" id="L248">		final TypedArray attributes = context.obtainStyledAttributes(attrs, R.styleable.Ui_Transition_Reveal, 0, 0);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">		for (int i = 0; i &lt; attributes.getIndexCount(); i++) {</span>
<span class="fc" id="L250">			final int index = attributes.getIndex(i);</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">			if (index == R.styleable.Ui_Transition_Reveal_uiRevealMode) {</span>
<span class="nc" id="L252">				setMode(attributes.getInteger(index, REVEAL));</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiStartRadius) {</span>
<span class="fc" id="L254">				this.mStartRadius = (float) attributes.getDimensionPixelSize(index, 0);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiEndRadius) {</span>
<span class="fc" id="L256">				this.mEndRadius = (float) attributes.getDimensionPixelSize(index, 0);</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiAppearVisibility) {</span>
<span class="fc" id="L258">				this.mAppearVisibility = attributes.getInteger(index, mAppearVisibility);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiDisappearVisibility) {</span>
<span class="fc" id="L260">				this.mDisappearVisibility = attributes.getInteger(index, mDisappearVisibility);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiStartVisibility) {</span>
<span class="fc" id="L262">				this.mStartVisibility = attributes.getInteger(index, mStartVisibility);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiEndVisibility) {</span>
<span class="fc" id="L264">				this.mEndVisibility = attributes.getInteger(index, mEndVisibility);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiCenterGravity) {</span>
<span class="fc" id="L266">				this.mCenterGravity = attributes.getInteger(index, 0);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiCenterVerticalOffset) {</span>
<span class="fc" id="L268">				this.mCenterVerticalOffset = attributes.getDimensionPixelSize(index, 0);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiCenterHorizontalOffset) {</span>
<span class="fc" id="L270">				this.mCenterHorizontalOffset = attributes.getDimensionPixelSize(index, 0);</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">			} else if (index == R.styleable.Ui_Transition_Reveal_android_centerX) {</span>
<span class="fc" id="L272">				this.mCenterXFraction = attributes.getFraction(index, 1, 1, mCenterXFraction);</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_android_centerY) {</span>
<span class="fc" id="L274">				this.mCenterYFraction = attributes.getFraction(index, 1, 1, mCenterYFraction);</span>
			}
		}
<span class="fc" id="L277">		attributes.recycle();</span>
<span class="fc" id="L278">	}</span>

	/*
	 * Methods =====================================================================================
	 */

	/**
	 * Same as {@link #calculateRadius(float, float)} where width and height of the given &lt;var&gt;view&lt;/var&gt;
	 * will be used for radius calculation.
	 *
	 * @param view The view of which radius to calculate.
	 * @return Calculated radius that may be used as end/start radius for the desired reveal animation.
	 */
	@FloatRange(from = 0)
	public static float calculateRadius(@NonNull final View view) {
<span class="fc" id="L293">		return calculateRadius(view.getWidth(), view.getHeight());</span>
	}

	/**
	 * Calculates the radius of the specified &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; dimension for
	 * purpose of circular reveal animation.
	 *
	 * @param width  The width or horizontal distance from which to calculate radius.
	 * @param height The height or vertical distance from which to calculate radius.
	 * @return Calculated radius that may be used as end/start radius for the desired reveal animation.
	 */
	@FloatRange(from = 0)
	public static float calculateRadius(@FloatRange(from = 0) final float width, @FloatRange(from = 0) final float height) {
<span class="fc" id="L306">		return (float) Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));</span>
	}

	/**
	 * Same as {@link #resolveCenterPosition(View, float, float)} with fraction {@code 0.5} for booth
	 * center coordinates.
	 */
	@Size(2)
	@NonNull
	public static float[] resolveCenterPosition(@NonNull final View view) {
<span class="fc" id="L316">		return resolveCenterPosition(view, CENTER_FRACTION, CENTER_FRACTION);</span>
	}

	/**
	 * Like {@link #resolveCenter(View, float, float)} this method will resolve center of the specified
	 * &lt;var&gt;view&lt;/var&gt; based on its current &lt;b&gt;width&lt;/b&gt; and &lt;b&gt;height&lt;/b&gt; but also takes into count
	 * its current &lt;b&gt;x&lt;/b&gt; and &lt;b&gt;y&lt;/b&gt; coordinate.
	 *
	 * @param view            The view of which center position to resolve.
	 * @param centerXFraction Fraction to resolve x coordinate of the center. Should be from the
	 *                        {@code [0.0, 1.0]} range.
	 * @param centerYFraction Fraction to resolve y coordinate of the center. Should be from the
	 *                        {@code [0.0, 1.0]} range.
	 * @return An array with center coordinates: centerX[0], centerY[1].
	 */
	@Size(2)
	@NonNull
	public static float[] resolveCenterPosition(
			@NonNull final View view,
			@FloatRange(from = 0, to = 1) final float centerXFraction,
			@FloatRange(from = 0, to = 1) final float centerYFraction
	) {
<span class="fc" id="L338">		final float[] center = resolveCenter(view, centerXFraction, centerYFraction);</span>
<span class="fc" id="L339">		return new float[]{</span>
<span class="fc" id="L340">				view.getX() + center[0],</span>
<span class="fc" id="L341">				view.getY() + center[1]</span>
		};
	}

	/**
	 * Same as {@link #resolveCenter(View, float, float)} with fraction {@code 0.5} for booth center
	 * coordinates.
	 */
	@Size(2)
	@NonNull
	public static float[] resolveCenter(@NonNull final View view) {
<span class="fc" id="L352">		return resolveCenter(view, CENTER_FRACTION, CENTER_FRACTION);</span>
	}

	/**
	 * Resolves the center of the specified &lt;var&gt;view&lt;/var&gt; based on its current &lt;var&gt;width&lt;/var&gt; and
	 * &lt;b&gt;height&lt;/b&gt; according to the requested fractions.
	 *
	 * @param view            The view of which center to resolve.
	 * @param centerXFraction Fraction to resolve x coordinate of the center. Should be from the
	 *                        {@code [0.0, 1.0]} range.
	 * @param centerYFraction Fraction to resolve y coordinate of the center. Should be from the
	 *                        {@code [0.0, 1.0]} range.
	 * @return An array with center coordinates: centerX[0], centerY[1].
	 */
	@Size(2)
	@NonNull
	public static float[] resolveCenter(
			@NonNull final View view,
			@FloatRange(from = 0, to = 1) final float centerXFraction,
			@FloatRange(from = 0, to = 1) final float centerYFraction
	) {
<span class="fc" id="L373">		return new float[]{</span>
<span class="fc" id="L374">				view.getWidth() * centerXFraction,</span>
<span class="fc" id="L375">				view.getHeight() * centerYFraction</span>
		};
	}

	/**
	 * Same as {@link #createAnimator(View, int, int, float, float)} where the center coordinates
	 * will be automatically resolved using the given &lt;var&gt;view&lt;/var&gt;.
	 *
	 * @see #resolveCenterPosition(View)
	 */
	@UiThread
	@Nullable
	public static Animator createAnimator(
			@NonNull final View view,
			@FloatRange(from = 0) final float radiusStart,
			@FloatRange(from = 0) final float radiusEnd
	) {
<span class="fc" id="L392">		final float[] center = resolveCenterPosition(view);</span>
<span class="fc" id="L393">		return createAnimator(view, Math.round(center[0]), Math.round(center[1]), radiusStart, radiusEnd);</span>
	}

	/**
	 * Creates a new instance of circular reveal Animator for the specified &lt;var&gt;view&lt;/var&gt;.
	 * &lt;p&gt;
	 * &lt;b&gt;Note, that this animator will be already wrapped in {@link AnimatorWrapper} which will have
	 * PAUSE and RESUME features disabled to ensure that there will be no exception thrown by the
	 * Android system if it tries to pause already running Reveal transition which cold possibly
	 * cause some exception to be thrown by the Android system.&lt;/b&gt;
	 * &lt;p&gt;
	 * The returned animator will also have the default {@link #INTERPOLATOR} attached.
	 *
	 * @param view        The view for which to create the requested animator.
	 * @param centerX     X coordinate of a center from where should the reveal animation start.
	 * @param centerY     Y coordinate of a center from where should the reveal animation start.
	 * @param radiusStart Radius of the specified view at the start of the reveal animation.
	 * @param radiusEnd   Radius of the specified view at the end of the reveal animation.
	 * @return Animator that will play circular reveal animation for the specified view according
	 * to the specified parameters when started or {@code null} if the start and end radii values
	 * are the same.
	 * @see ViewAnimationUtils#createCircularReveal(View, int, int, float, float)
	 */
	@UiThread
	@Nullable
	public static Animator createAnimator(
			@NonNull final View view,
			@IntRange(from = 0) final int centerX,
			@IntRange(from = 0) final int centerY,
			@FloatRange(from = 0) final float radiusStart,
			@FloatRange(from = 0) final float radiusEnd
	) {
<span class="fc bfc" id="L425" title="All 2 branches covered.">		if (radiusStart == radiusEnd) {</span>
<span class="fc" id="L426">			return null;</span>
		}
<span class="fc" id="L428">		final AnimatorWrapper animatorWrapper = new AnimatorWrapper(ViewAnimationUtils.createCircularReveal(</span>
				view,
				centerX, centerY,
				radiusStart, radiusEnd
		));
<span class="fc" id="L433">		animatorWrapper.setInterpolator(INTERPOLATOR);</span>
<span class="fc" id="L434">		animatorWrapper.removeFeature(AnimatorWrapper.PAUSE | AnimatorWrapper.RESUME);</span>
<span class="fc" id="L435">		return animatorWrapper;</span>
	}

	/**
	 * Sets a mode in which should this transition run.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link #REVEAL}&lt;/b&gt;
	 *
	 * @param mode The desired mode. One of {@link #REVEAL} or {@link #CONCEAL}.
	 * @see #getMode()
	 */
	@Override
	public final void setMode(@RevealMode final int mode) {
<span class="fc" id="L448">		this.mMode = mode;</span>
<span class="fc" id="L449">	}</span>

	/**
	 * Returns the reveal mode of this transition.
	 *
	 * @return One of {@link #REVEAL} or {@link #CONCEAL}.
	 */
	@RevealMode
	public final int getMode() {
<span class="fc" id="L458">		return mMode;</span>
	}

	/**
	 * Sets a start radius for animating circle of the reveal animation. Based on the current reveal
	 * mode, this radius should be either smaller than the end radius specified via {@link #setEndRadius(Float)}
	 * or grater one otherwise there will be nothing to reveal/conceal.
	 *
	 * @param radius The desired radius in pixels. May be {@code null} to use the default approach
	 *               to compute start radius based on the reveal mode.
	 * @see R.attr#uiStartRadius ui:uiStartRadius
	 * @see #getStartRadius()
	 * @see #setEndRadius(Float)
	 */
	public void setStartRadius(@Nullable final Float radius) {
<span class="fc" id="L473">		this.mStartRadius = radius;</span>
<span class="fc" id="L474">	}</span>

	/**
	 * Returns the start radius for animating circle of the reveal animation.
	 *
	 * @return Start radius in pixels or {@code null} if this radius will be calculated based on the
	 * reveal mode.
	 * @see #setStartRadius(Float)
	 */
	@Nullable
	public Float getStartRadius() {
<span class="fc" id="L485">		return mStartRadius;</span>
	}

	/**
	 * Sets an end radius for animating circle of the reveal animation. Based on the current reveal
	 * mode, this radius should be either greater than the start radius specified via {@link #setStartRadius(Float)}
	 * or smaller one otherwise there will be nothing to reveal/conceal.
	 *
	 * @param radius The desired radius in pixels. May be {@code null} to use the default approach
	 *               to compute end radius based on the reveal mode.
	 * @see R.attr#uiEndRadius ui:uiEndRadius
	 * @see #getEndRadius()
	 * @see #setStartRadius(Float)
	 */
	public void setEndRadius(@Nullable final Float radius) {
<span class="fc" id="L500">		this.mEndRadius = radius;</span>
<span class="fc" id="L501">	}</span>

	/**
	 * Returns the end radius for animating circle of the reveal animation.
	 *
	 * @return End radius in pixels or {@code null} if this radius will be calculated based on the
	 * reveal mode.
	 * @see #setEndRadius(Float)
	 */
	@Nullable
	public Float getEndRadius() {
<span class="fc" id="L512">		return mEndRadius;</span>
	}

	/**
	 * Sets a visibility flag that should be set to a revealing view whenever this transition starts.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link View#VISIBLE VISIBLE}&lt;/b&gt;
	 *
	 * @param visibility One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see R.attr#uiStartVisibility ui:uiStartVisibility
	 * @see #getStartVisibility()
	 */
	public void setStartVisibility(final int visibility) {
<span class="fc" id="L525">		this.mStartVisibility = visibility;</span>
<span class="fc" id="L526">	}</span>

	/**
	 * Returns the visibility flag that will be set to a revealing view whenever this transition
	 * (its animation) starts.
	 *
	 * @return One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see #setStartVisibility(int)
	 */
	public int getStartVisibility() {
<span class="fc" id="L536">		return mStartVisibility;</span>
	}

	/**
	 * Sets a visibility flag that should be set to a revealing view whenever this transition
	 * (its animation) ends.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link View#VISIBLE VISIBLE}&lt;/b&gt;
	 *
	 * @param visibility One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see R.attr#uiEndVisibility ui:uiEndVisibility
	 * @see #getEndVisibility()
	 */
	public void setEndVisibility(final int visibility) {
<span class="fc" id="L550">		this.mEndVisibility = visibility;</span>
<span class="fc" id="L551">	}</span>

	/**
	 * Returns the visibility flag that will be set to a revealing view whenever this transition ends.
	 *
	 * @return One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see #setEndVisibility(int)
	 */
	public int getEndVisibility() {
<span class="fc" id="L560">		return mEndVisibility;</span>
	}

	/**
	 * Sets a visibility flag that should be set to a revealing view whenever this transition has
	 * been requested to create an appear animator via {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link View#VISIBLE VISIBLE}&lt;/b&gt;
	 *
	 * @param visibility One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see R.attr#uiAppearVisibility ui:uiAppearVisibility
	 * @see #getAppearVisibility()
	 */
	public void setAppearVisibility(final int visibility) {
<span class="fc" id="L574">		this.mAppearVisibility = visibility;</span>
<span class="fc" id="L575">	}</span>

	/**
	 * Returns the visibility flag that will be set to a revealing view whenever this transition is
	 * requested to create an appear animator.
	 *
	 * @return One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see #setAppearVisibility(int)
	 */
	public int getAppearVisibility() {
<span class="fc" id="L585">		return mAppearVisibility;</span>
	}

	/**
	 * Sets a visibility flag that should be set to a revealing view whenever this transition has
	 * been requested to create a disappear animator via {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link View#VISIBLE VISIBLE}&lt;/b&gt;
	 *
	 * @param visibility One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see R.attr#uiDisappearVisibility ui:uiDisappearVisibility
	 * @see #getDisappearVisibility()
	 */
	public void setDisappearVisibility(final int visibility) {
<span class="fc" id="L599">		this.mDisappearVisibility = visibility;</span>
<span class="fc" id="L600">	}</span>

	/**
	 * Returns the visibility flag that will be set to a revealing view whenever this transition is
	 * requested to created a disappear animator.
	 *
	 * @return One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see #setDisappearVisibility(int)
	 */
	public int getDisappearVisibility() {
<span class="fc" id="L610">		return mDisappearVisibility;</span>
	}

	/**
	 * Sets a gravity flags that should be used to resolve center for animating circle of the reveal
	 * animation.
	 * &lt;p&gt;
	 * Sometimes the gravity is not enough to specify exact center coordinates for the reveal animation.
	 * In such case you can move the center coordinates calculated by the requested gravity by
	 * specifying horizontal and vertical offset via {@link #setCenterHorizontalOffset(int)} and
	 * {@link #setCenterVerticalOffset(int)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code null}&lt;/b&gt;
	 *
	 * @param gravity One of {@link Gravity#CENTER}, {@link Gravity#CENTER_VERTICAL}, {@link Gravity#CENTER_HORIZONTAL},
	 *                {@link Gravity#TOP}, {@link Gravity#BOTTOM}, {@link Gravity#START}, {@link Gravity#END}
	 *                or theirs combination. May be {@code null} to use either specified exact center
	 *                coordinates or the specified fractions to calculate such coordinates.
	 * @see R.attr#uiCenterGravity ui:uiCenterGravity
	 * @see #getCenterGravity()
	 * @see #setCenterX(Float)
	 * @see #setCenterY(Float)
	 * @see #setCenterXFraction(float)
	 * @see #setCenterYFraction(float)
	 */
	public void setCenterGravity(@Nullable final Integer gravity) {
<span class="fc" id="L636">		this.mCenterGravity = gravity;</span>
<span class="fc" id="L637">	}</span>

	/**
	 * Returns the gravity flags that will be used to resolve center for animating circle of the
	 * reveal animation.
	 *
	 * @return One of {@link Gravity#CENTER}, {@link Gravity#CENTER_VERTICAL}, {@link Gravity#CENTER_HORIZONTAL},
	 * {@link Gravity#TOP}, {@link Gravity#BOTTOM}, {@link Gravity#START}, {@link Gravity#END} or
	 * theirs combination or {@code null} if no gravity has been specified so either center coordinates
	 * specified via {@link #setCenterX(Float)} and {@link #setCenterY(Float)} will be used or calculated
	 * using the current center fraction values.
	 * @see #setCenterGravity(Integer)
	 */
	@Nullable
	public Integer getCenterGravity() {
<span class="fc" id="L652">		return mCenterGravity;</span>
	}

	/**
	 * Sets an offset for the &lt;b&gt;center x&lt;/b&gt; coordinate for animating circle of the reveal animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code 0}&lt;/b&gt;
	 *
	 * @param offset The desired offset in pixels. If negative the center x coordinate will be moved
	 *               the the left, if positive it will be moved to the right, otherwise remains
	 *               unchanged.
	 * @see R.attr#uiCenterHorizontalOffset ui:uiCenterHorizontalOffset
	 * @see #getCenterHorizontalOffset()
	 * @see #setCenterVerticalOffset(int)
	 */
	public void setCenterHorizontalOffset(final int offset) {
<span class="fc" id="L668">		this.mCenterHorizontalOffset = offset;</span>
<span class="fc" id="L669">	}</span>

	/**
	 * Returns the offset for the &lt;b&gt;center x&lt;/b&gt; coordinate for animating circle of the reveal animation.
	 *
	 * @return Horizontal offset in pixels.
	 * @see #setCenterHorizontalOffset(int)
	 */
	public int getCenterHorizontalOffset() {
<span class="fc" id="L678">		return mCenterHorizontalOffset;</span>
	}

	/**
	 * Sets an offset for the &lt;b&gt;center y&lt;/b&gt; coordinate for animating circle of the reveal animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code 0}&lt;/b&gt;
	 *
	 * @param offset The desired offset in pixels. If negative the center y coordinate will be moved
	 *               the the top, if positive it will be moved to the bottom, otherwise remains
	 *               unchanged.
	 * @see R.attr#uiCenterVerticalOffset ui:uiCenterVerticalOffset
	 * @see #getCenterVerticalOffset()
	 * @see #setCenterHorizontalOffset(int)
	 */
	public void setCenterVerticalOffset(final int offset) {
<span class="fc" id="L694">		this.mCenterVerticalOffset = offset;</span>
<span class="fc" id="L695">	}</span>

	/**
	 * Returns the offset for the &lt;b&gt;center y&lt;/b&gt; coordinate for animating circle of the reveal animation.
	 *
	 * @return Vertical offset in pixels.
	 * @see #setCenterVerticalOffset(int)
	 */
	public int getCenterVerticalOffset() {
<span class="fc" id="L704">		return mCenterVerticalOffset;</span>
	}

	/**
	 * Sets a center x coordinate for animating circle of the reveal animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code null}&lt;/b&gt;
	 *
	 * @param centerX The desired center x coordinate in pixels. May be {@code null} to use center
	 *                x fraction specified via {@link #setCenterXFraction(float)} instead.
	 * @see #getCenterX()
	 * @see #setCenterXFraction(float)
	 * @see #setCenterY(Float)
	 */
	public void setCenterX(@Nullable final Float centerX) {
<span class="fc" id="L719">		this.mCenterX = centerX;</span>
<span class="fc" id="L720">	}</span>

	/**
	 * Returns the x coordinate of the center for animating circle of the reveal animation.
	 *
	 * @return X coordinate of the center for animating circle in pixels or {@code null} if no coordinate
	 * has been specified so the fraction will be used to calculate this center coordinate.
	 * @see #setCenterX(Float)
	 */
	@Nullable
	public Float getCenterX() {
<span class="fc" id="L731">		return mCenterX;</span>
	}

	/**
	 * Sets a center y coordinate for animating circle of the reveal animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code null}&lt;/b&gt;
	 *
	 * @param centerY The desired center y coordinate in pixels. May be {@code null} to use center
	 *                y fraction specified via {@link #setCenterYFraction(float)} instead.
	 * @see #getCenterY()
	 * @see #setCenterYFraction(float)
	 * @see #setCenterX(Float)
	 */
	public void setCenterY(@Nullable final Float centerY) {
<span class="fc" id="L746">		this.mCenterY = centerY;</span>
<span class="fc" id="L747">	}</span>

	/**
	 * Returns the y coordinate of the center for animating circle of the reveal animation.
	 *
	 * @return Y coordinate of the center for animating circle in pixels or {@code null} if no coordinate
	 * has been specified so the fraction will be used to calculate this center coordinate.
	 * @see #setCenterY(Float)
	 */
	@Nullable
	public Float getCenterY() {
<span class="fc" id="L758">		return mCenterY;</span>
	}

	/**
	 * Sets a fraction for the &lt;b&gt;center x&lt;/b&gt; coordinate. This fraction will be used to resolve
	 * center x coordinate of an animating view depending on its current &lt;b&gt;width&lt;/b&gt; if such value
	 * has not been specified via {@link #setCenterX(Float)}.
	 * &lt;p&gt;
	 * Sometimes the fraction is not enough to specify exact center coordinate for the reveal animation.
	 * In such case you can move the center coordinates calculated by the requested fractions by
	 * specifying horizontal and vertical offset via {@link #setCenterHorizontalOffset(int)} and
	 * {@link #setCenterVerticalOffset(int)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code 0.5}&lt;/b&gt;
	 *
	 * @param fractionX The desired fraction from the {@code [0.0, 1.0]} range.
	 * @see android.R.attr#centerX android:centerX
	 * @see #getCenterXFraction()
	 * @see #setCenterYFraction(float)
	 * @see #setCenterX(Float)
	 */
	public void setCenterXFraction(@FloatRange(from = 0, to = 1) final float fractionX) {
<span class="fc" id="L780">		this.mCenterXFraction = Math.max(0, Math.min(1, fractionX));</span>
<span class="fc" id="L781">	}</span>

	/**
	 * Returns the fraction of the &lt;b&gt;center x&lt;/b&gt; coordinate.
	 *
	 * @return Fraction from the {@code [0.0, 1.0]} range.
	 * @see #setCenterXFraction(float)
	 */
	@FloatRange(from = 0, to = 1)
	public float getCenterXFraction() {
<span class="fc" id="L791">		return mCenterXFraction;</span>
	}

	/**
	 * Sets a fraction for the &lt;b&gt;center y&lt;/b&gt; coordinate. This fraction will be used to resolve
	 * center y coordinate of an animating view depending on its current &lt;b&gt;height&lt;/b&gt; if such value
	 * has not been specified via {@link #setCenterY(Float)}.
	 * &lt;p&gt;
	 * Sometimes the fraction is not enough to specify exact center coordinate for the reveal animation.
	 * In such case you can move the center coordinates calculated by the requested fractions by
	 * specifying horizontal and vertical offset via {@link #setCenterHorizontalOffset(int)} and
	 * {@link #setCenterVerticalOffset(int)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code 0.5}&lt;/b&gt;
	 *
	 * @param fractionY The desired fraction from the {@code [0.0, 1.0]} range.
	 * @see android.R.attr#centerY android:centerY
	 * @see #getCenterYFraction()
	 * @see #setCenterXFraction(float)
	 * @see #setCenterY(Float)
	 */
	public void setCenterYFraction(@FloatRange(from = 0, to = 1) final float fractionY) {
<span class="fc" id="L813">		this.mCenterYFraction = Math.max(0, Math.min(1, fractionY));</span>
<span class="fc" id="L814">	}</span>

	/**
	 * Returns the fraction of the &lt;b&gt;center y&lt;/b&gt; coordinate.
	 *
	 * @return Fraction from the {@code [0.0, 1.0]} range.
	 * @see #setCenterYFraction(float)
	 */
	@FloatRange(from = 0, to = 1)
	public float getCenterYFraction() {
<span class="fc" id="L824">		return mCenterYFraction;</span>
	}

	/**
	 */
	@Override
	public Animator onAppear(
			@NonNull final ViewGroup sceneRoot,
			@NonNull final View view,
			@Nullable final TransitionValues startValues,
			@Nullable final TransitionValues endValues
	) {
<span class="fc" id="L836">		calculateTransitionProperties(view);</span>
<span class="fc" id="L837">		final Animator animator = createAnimatorFromInfo(view);</span>
<span class="fc" id="L838">		animator.addListener(new TransitionAnimatorListener(view, mStartVisibility, mEndVisibility));</span>
<span class="fc" id="L839">		view.setVisibility(mAppearVisibility);</span>
<span class="fc" id="L840">		return animator;</span>
	}

	/**
	 */
	@Override
	public Animator onDisappear(
			@NonNull final ViewGroup sceneRoot,
			@NonNull final View view,
			@Nullable final TransitionValues startValues,
			@Nullable final TransitionValues endValues
	) {
<span class="fc" id="L852">		calculateTransitionProperties(view);</span>
<span class="fc" id="L853">		final Animator animator = createAnimatorFromInfo(view);</span>
<span class="fc" id="L854">		animator.addListener(new TransitionAnimatorListener(view, mStartVisibility, mEndVisibility));</span>
<span class="fc" id="L855">		view.setVisibility(mDisappearVisibility);</span>
<span class="fc" id="L856">		return animator;</span>
	}

	/**
	 * Ensures that all necessary properties for this transition are calculated.
	 *
	 * @param view The view to which will be the transition applied.
	 */
	@VisibleForTesting
	void calculateTransitionProperties(final View view) {
		// First calculate center of the reveal transition.
		final float[] center;
<span class="fc bfc" id="L868" title="All 2 branches covered.">		if (mCenterGravity == null) {</span>
<span class="fc" id="L869">			center = resolveCenter(view, mCenterXFraction, mCenterYFraction);</span>
		} else {
<span class="fc" id="L871">			center = resolveGravityCenter(view);</span>
		}
<span class="fc bfc" id="L873" title="All 2 branches covered.">		final float centerX = mCenterX == null ? center[0] : mCenterX;</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">		final float centerY = mCenterY == null ? center[1] : mCenterY;</span>
<span class="fc" id="L875">		mInfo.centerX = centerX + mCenterHorizontalOffset;</span>
<span class="fc" id="L876">		mInfo.centerY = centerY + mCenterVerticalOffset;</span>
		// Now calculate start with end radius of the reveal transition.
<span class="fc" id="L878">		final float[] radii = calculateTransitionRadii(view);</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">		mInfo.startRadius = mStartRadius == null ? radii[0] : mStartRadius;</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">		mInfo.endRadius = mEndRadius == null ? radii[1] : mEndRadius;</span>
<span class="fc" id="L881">	}</span>

	/**
	 * Returns info for the current reveal animation configuration.
	 *
	 * @return Current reveal info.
	 * @see #calculateTransitionProperties(View)
	 */
	@NonNull
	@VisibleForTesting
	final Info getInfo() {
<span class="fc" id="L892">		return mInfo;</span>
	}

	/**
	 * Resolves center coordinates for the reveal animation of the specified &lt;var&gt;view&lt;/var&gt; depending
	 * on the current value of {@link #mCenterGravity}.
	 *
	 * @param view The view for which will be the reveal animation run.
	 * @return An array with center coordinates: centerX[0], centerY[1].
	 */
	@SuppressLint(&quot;RtlHardcoded&quot;)
	private float[] resolveGravityCenter(final View view) {
<span class="fc" id="L904">		final float[] center = new float[]{0, 0};</span>
<span class="fc" id="L905">		final int viewWidth = view.getWidth();</span>
<span class="fc" id="L906">		final int viewHeight = view.getHeight();</span>
<span class="fc" id="L907">		final int layoutDirection = view.getLayoutDirection();</span>
<span class="fc" id="L908">		final int absoluteGravity = Gravity.getAbsoluteGravity(mCenterGravity, layoutDirection);</span>
<span class="fc" id="L909">		final int horizontalGravity = absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK;</span>
<span class="fc" id="L910">		final int verticalGravity = mCenterGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span>
		// Resolve center horizontal coordinate.
<span class="fc bfc" id="L912" title="All 3 branches covered.">		switch (horizontalGravity) {</span>
			case Gravity.CENTER_HORIZONTAL:
<span class="fc" id="L914">				center[0] = viewWidth / 2f;</span>
<span class="fc" id="L915">				break;</span>
			case Gravity.RIGHT:
<span class="fc" id="L917">				center[0] = viewWidth;</span>
<span class="fc" id="L918">				break;</span>
			case Gravity.LEFT:
			default:
<span class="fc" id="L921">				center[0] = 0;</span>
				break;
		}
		// Resolve center vertical coordinate.
<span class="fc bfc" id="L925" title="All 3 branches covered.">		switch (verticalGravity) {</span>
			case Gravity.CENTER_VERTICAL:
<span class="fc" id="L927">				center[1] = viewHeight / 2f;</span>
<span class="fc" id="L928">				break;</span>
			case Gravity.BOTTOM:
<span class="fc" id="L930">				center[1] = viewHeight;</span>
<span class="fc" id="L931">				break;</span>
			case Gravity.TOP:
			default:
<span class="fc" id="L934">				center[1] = 0;</span>
				break;
		}
<span class="fc" id="L937">		return center;</span>
	}

	/**
	 * Calculates start and end radius for the reveal animation of the specified &lt;var&gt;view&lt;/var&gt;
	 * depending on the current {@link #mMode}.
	 *
	 * @param view The view for which reveal animation to calculate start and end radius.
	 * @return An array with two radii: startRadius[0], endRadius[1].
	 */
	private float[] calculateTransitionRadii(final View view) {
		final float startRadius;
		final float endRadius;
<span class="fc bfc" id="L950" title="All 2 branches covered.">		switch (mMode) {</span>
			case CONCEAL:
<span class="fc" id="L952">				startRadius = calculateTransitionRadius(view);</span>
<span class="fc" id="L953">				endRadius = 0;</span>
<span class="fc" id="L954">				break;</span>
			case REVEAL:
			default:
<span class="fc" id="L957">				startRadius = 0;</span>
<span class="fc" id="L958">				endRadius = calculateTransitionRadius(view);</span>
				break;
		}
<span class="fc" id="L961">		return new float[]{startRadius, endRadius};</span>
	}

	/**
	 * Calculates radius for the reveal transition for the specified &lt;var&gt;view&lt;/var&gt;.
	 * The radius is calculated depending on how big distance should be traveled from the current
	 * center coordinates to the outermost edge of the given view.
	 * &lt;p&gt;
	 * &lt;b&gt;Note, that this method assumes that center coordinates for the reveal transitions has
	 * been already calculated and are presented in {@link #mInfo}&lt;/b&gt;.
	 *
	 * @param view The view for which reveal animation to calculate the requested radius.
	 * @return Calculated radius that should be used as end/start radius for reveal animation
	 * depends on its current mode.
	 */
	private float calculateTransitionRadius(final View view) {
		final float horizontalDistance;
		final float verticalDistance;
<span class="fc" id="L979">		final float centerX = mInfo.centerX;</span>
<span class="fc" id="L980">		final float centerY = mInfo.centerY;</span>
<span class="fc" id="L981">		final float viewWidth = view.getWidth();</span>
<span class="fc" id="L982">		final float viewHeight = view.getHeight();</span>
<span class="fc" id="L983">		final float[] viewCenter = resolveCenter(view);</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">		if (centerX &gt;= viewCenter[0]) {</span>
<span class="fc" id="L985">			horizontalDistance = centerX / viewWidth * viewWidth;</span>
		} else {
<span class="fc" id="L987">			horizontalDistance = (1 - (centerX / viewWidth)) * viewWidth;</span>
		}
<span class="fc bfc" id="L989" title="All 2 branches covered.">		if (centerY &gt;= viewCenter[1]) {</span>
<span class="fc" id="L990">			verticalDistance = centerY / viewHeight * viewHeight;</span>
		} else {
<span class="fc" id="L992">			verticalDistance = (1 - (centerY / viewHeight)) * viewHeight;</span>
		}
<span class="fc" id="L994">		return calculateRadius(horizontalDistance, verticalDistance);</span>
	}

	/**
	 * Creates a new instance of circular reveal Animator for the specified &lt;var&gt;view&lt;/var&gt; with current
	 * reveal properties specified within {@link #mInfo}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note, that this animator will be already wrapped in {@link AnimatorWrapper} which will have
	 * PAUSE and RESUME features disabled to ensure that there will be no exception thrown by the
	 * Android system if it tries to pause already running Reveal transition where such situation
	 * is not properly handled by the system at this time.&lt;/b&gt;
	 *
	 * @param view The view for which to create the requested animator.
	 * @return Animator that will play circular reveal animation when started.
	 */
	private Animator createAnimatorFromInfo(final View view) {
<span class="fc" id="L1010">		return createAnimator(</span>
				view,
<span class="fc" id="L1012">				Math.round(mInfo.centerX),</span>
<span class="fc" id="L1013">				Math.round(mInfo.centerY),</span>
				mInfo.startRadius,
				mInfo.endRadius
		);
	}

	/*
	 * Inner classes ===============================================================================
	 */

	/**
	 * Class holding necessary values for the reveal transition that are exclusively associated with
	 * the currently transitioning view.
	 */
	@VisibleForTesting
<span class="fc" id="L1028">	static final class Info {</span>

		/**
		 * Reveal circle radius.
		 */
		float startRadius, endRadius;

		/**
		 * Reveal circle center coordinate.
		 */
		float centerX, centerY;
	}

	/**
	 * Listener that is used by {@link Reveal} transition to change properties of the animating view
	 * according to the received animation callbacks.
	 */
	@VisibleForTesting
	static final class TransitionAnimatorListener extends AnimatorListenerAdapter {

		/**
		 * View of which properties to change due to received animation callbacks.
		 */
		private final View animatingView;

		/**
		 * Visibility to be applied to the view on animation start.
		 */
		private final int visibilityStart;

		/**
		 * Visibility to be applied to the view on animation end.
		 */
		private final int visibilityEnd;

		/**
		 * Creates a new instance of TransitionAnimatorListener for the specified view.
		 *
		 * @param animatingView   The animating view of which properties may be changed by the
		 *                        animator listener as result of received animation callbacks.
		 * @param visibilityStart Visibility to be applied to the view on animation start.
		 * @param visibilityEnd   Visibility to be applied to the view on animation end.
		 */
		TransitionAnimatorListener(final View animatingView, final int visibilityStart, final int visibilityEnd) {
<span class="fc" id="L1072">			super();</span>
<span class="fc" id="L1073">			this.animatingView = animatingView;</span>
<span class="fc" id="L1074">			this.visibilityStart = visibilityStart;</span>
<span class="fc" id="L1075">			this.visibilityEnd = visibilityEnd;</span>
<span class="fc" id="L1076">		}</span>

		/**
		 */
		@Override
		public void onAnimationStart(@NonNull final Animator animation) {
<span class="fc" id="L1082">			animatingView.setVisibility(visibilityStart);</span>
<span class="fc" id="L1083">		}</span>

		/**
		 */
		@Override
		public void onAnimationEnd(@NonNull final Animator animation) {
<span class="fc" id="L1089">			animatingView.setVisibility(visibilityEnd);</span>
<span class="fc" id="L1090">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.3</div></body></html>