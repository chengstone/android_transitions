<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Reveal.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.transition</a> &gt; <span class="el_source">Reveal.java</span></div><h1>Reveal.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.transition;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.TypedArray;
import android.os.Build;
import android.support.annotation.FloatRange;
import android.support.annotation.IntDef;
import android.support.annotation.IntRange;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.Size;
import android.transition.TransitionValues;
import android.transition.Visibility;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.view.ViewAnimationUtils;
import android.view.ViewGroup;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import universum.studios.android.transition.util.AnimatorWrapper;

/**
 * A {@link Visibility} transition implementation that tracks changes to the visibility of target
 * views in the start and end scenes and reveals or conceals views in the scene. Visibility is
 * determined by the {@link View#setVisibility(int)} state of the views.
 * &lt;p&gt;
 * A Reveal transition uses {@link ViewAnimationUtils#createCircularReveal(View, int, int, float, float)}
 * to create a circular reveal/conceal animator that is used to animate its target views. A center
 * coordinates of revealing/concealing circle can be specified via {@link #setCenterX(Float)} and
 * {@link #setCenterY(Float)} or by using fractions via {@link #setCenterXFraction(float)} and
 * {@link #setCenterYFraction(float)}. If specifying a gravity for the center of the animating circle
 * is enough, the desired gravity flags may be specified via {@link #setCenterGravity(Integer)}.
 * &lt;p&gt;
 * Reveal transition can be described in a resource file by using the {@code transition} tag with
 * {@code class} attribute set to {@code universum.studios.android.transition.Reveal}, along with
 * Xml attributes referenced below.
 *
 * &lt;h3&gt;XML attributes&lt;/h3&gt;
 * {@link R.styleable#Ui_Transition_Reveal Reveal Attributes}
 *
 * @author Martin Albedinsky
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public class Reveal extends Visibility {

	/*
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;Reveal&quot;;

	/**
	 * Mode to indicate that Reveal transition should play &lt;b&gt;reveal&lt;/b&gt; animation, that is to
	 * 'upscale' the animating circle of an animating view from its initial size to a larger one.
	 * &lt;p&gt;
	 * This mode can be used as well for &lt;b&gt;appearing&lt;/b&gt; targets as for &lt;b&gt;disappearing&lt;/b&gt; ones.
	 */
	public static final int REVEAL = MODE_IN;

	/**
	 * Mode to indicate that Reveal transition should play &lt;b&gt;conceal&lt;/b&gt; animation, that is to
	 * 'downscale' the animating circle of an animating view from its initial size to a smaller one.
	 * &lt;p&gt;
	 * This mode can be used as well for &lt;b&gt;disappearing&lt;/b&gt; targets as for &lt;b&gt;appearing&lt;/b&gt; ones.
	 */
	public static final int CONCEAL = MODE_OUT;

	/**
	 * Defines an annotation for determining set of allowed modes for Reveal transition.
	 */
	@Retention(RetentionPolicy.SOURCE)
	@IntDef({REVEAL, CONCEAL})
	public @interface RevealMode {
	}

	/**
	 * Default value for center fraction.
	 */
	private static final float CENTER_FRACTION = 0.5f;

	/*
	 * Interface ===================================================================================
	 */

	/*
	 * Static members ==============================================================================
	 */

	/*
	 * Members =====================================================================================
	 */

	/**
	 * Object that holds all necessary properties for the reveal transition for the currently
	 * transitioning view.
	 */
<span class="nc" id="L125">	private final Info mInfo = new Info();</span>

	/**
	 * Mode determining whether we will run &lt;b&gt;reveal&lt;/b&gt; or &lt;b&gt;conceal&lt;/b&gt; animation.
	 * Either {@link #REVEAL} or {@link #CONCEAL}.
	 */
<span class="nc" id="L131">	private int mMode = REVEAL;</span>

	/**
	 * X coordinate for center of the reveal/conceal animation. If {@code null}, {@link #mCenterXFraction}
	 * should be used to calculate this coordinate.
	 */
	private Float mCenterX;

	/**
	 * Y coordinate for center of the reveal/conceal animation. If {@code null}, {@link #mCenterYFraction}
	 * should be used to calculate this coordinate.
	 */
	private Float mCenterY;

	/**
	 * Fraction from the {@code [0.0, 1.0]} range that can be used to calculate X coordinate for center
	 * of the reveal/conceal animation if {@link #mCenterX} coordinate has not been specified.
	 */
<span class="nc" id="L149">	private float mCenterXFraction = CENTER_FRACTION;</span>

	/**
	 * Fraction from the {@code [0.0, 1.0]} range that can be used to calculate Y coordinate for center
	 * of the reveal/conceal animation if {@link #mCenterY} coordinate has not been specified.
	 */
<span class="nc" id="L155">	private float mCenterYFraction = CENTER_FRACTION;</span>

	/**
	 * Gravity flags used to resolve center coordinates for the reveal/conceal animation.
	 * If {@code null}, values specified for {@link #mCenterX} and {@link #mCenterY} should be used
	 * as center coordinates.
	 */
	private Integer mCenterGravity;

	/**
	 * Value in pixels by which to offset {@link #mCenterY} vertically.
	 */
	private int mCenterVerticalOffset;

	/**
	 * Value in pixels by which to offset {@link #mCenterX} horizontally.
	 */
	private int mCenterHorizontalOffset;

	/**
	 * Start radius for circle of the reveal/conceal animation.
	 */
	private Float mStartRadius;

	/**
	 * End radius for circle of the reveal/conceal animation.
	 */
	private Float mEndRadius;

	/**
	 * Visibility flag set to a revealing view whenever the reveal animation starts.
	 */
<span class="nc" id="L187">	private int mStartVisibility = View.VISIBLE;</span>

	/**
	 * Visibility flag set to a revealing view whenever the reveal animation ends.
	 */
<span class="nc" id="L192">	private int mEndVisibility = View.VISIBLE;</span>

	/**
	 * Visibility flag set to a revealing view whenever {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}
	 * is invoked.
	 */
<span class="nc" id="L198">	private int mAppearVisibility = View.VISIBLE;</span>

	/**
	 * Visibility flag set to a revealing view whenever {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
	 * is invoked.
	 */
<span class="nc" id="L204">	private int mDisappearVisibility = View.VISIBLE;</span>

	/*
	 * Constructors ================================================================================
	 */

	/**
	 * Same as {@link #Reveal(int)} with {@link #REVEAL} mode.
	 */
	public Reveal() {
<span class="nc" id="L214">		this(REVEAL);</span>
<span class="nc" id="L215">	}</span>

	/**
	 * Creates a new instance of Reveal transition with the specified &lt;var&gt;mode&lt;/var&gt;.
	 *
	 * @param mode One of {@link #REVEAL} or {@link #CONCEAL}.
	 */
	public Reveal(@RevealMode final int mode) {
<span class="nc" id="L223">		super();</span>
<span class="nc" id="L224">		setMode(mode);</span>
<span class="nc" id="L225">	}</span>

	/**
	 * Creates a new instance of Reveal transition with animation property values set from the
	 * specified &lt;var&gt;attrs&lt;/var&gt;.
	 *
	 * @param context Context used to obtain values from the specified &lt;var&gt;attrs&lt;/var&gt;.
	 * @param attrs   Set of attributes from which to obtain property values for the reveal animation.
	 */
	@SuppressWarnings(&quot;ResourceType&quot;)
	public Reveal(@NonNull final Context context, @NonNull final AttributeSet attrs) {
<span class="nc" id="L236">		super(context, attrs);</span>
<span class="nc" id="L237">		final TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.Ui_Transition_Reveal, 0, 0);</span>
<span class="nc" id="L238">		final int n = typedArray.getIndexCount();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">		for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L240">			final int index = typedArray.getIndex(i);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">			if (index == R.styleable.Ui_Transition_Reveal_uiRevealMode) {</span>
<span class="nc" id="L242">				setMode(typedArray.getInteger(index, REVEAL));</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiStartRadius) {</span>
<span class="nc" id="L244">				this.mStartRadius = (float) typedArray.getDimensionPixelSize(index, 0);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiEndRadius) {</span>
<span class="nc" id="L246">				this.mEndRadius = (float) typedArray.getDimensionPixelSize(index, 0);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiAppearVisibility) {</span>
<span class="nc" id="L248">				this.mAppearVisibility = typedArray.getInteger(index, mAppearVisibility);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiDisappearVisibility) {</span>
<span class="nc" id="L250">				this.mDisappearVisibility = typedArray.getInteger(index, mDisappearVisibility);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiStartVisibility) {</span>
<span class="nc" id="L252">				this.mStartVisibility = typedArray.getInteger(index, mStartVisibility);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiEndVisibility) {</span>
<span class="nc" id="L254">				this.mEndVisibility = typedArray.getInteger(index, mEndVisibility);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiCenterGravity) {</span>
<span class="nc" id="L256">				this.mCenterGravity = typedArray.getInteger(index, 0);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiCenterVerticalOffset) {</span>
<span class="nc" id="L258">				this.mCenterVerticalOffset = typedArray.getDimensionPixelSize(index, 0);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_uiCenterHorizontalOffset) {</span>
<span class="nc" id="L260">				this.mCenterHorizontalOffset = typedArray.getDimensionPixelSize(index, 0);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_android_centerX) {</span>
<span class="nc" id="L262">				this.mCenterXFraction = typedArray.getFraction(index, 1, 1, mCenterXFraction);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">			} else if (index == R.styleable.Ui_Transition_Reveal_android_centerY) {</span>
<span class="nc" id="L264">				this.mCenterYFraction = typedArray.getFraction(index, 1, 1, mCenterYFraction);</span>
			}
		}
<span class="nc" id="L267">		typedArray.recycle();</span>
<span class="nc" id="L268">	}</span>

	/*
	 * Methods =====================================================================================
	 */

	/**
	 * Same as {@link #calculateRadius(float, float)} where width and height of the given &lt;var&gt;view&lt;/var&gt;
	 * will be used for radius calculation.
	 *
	 * @param view The view of which radius to calculate.
	 * @return Calculated radius that may be used as end/start radius for the desired reveal animation.
	 */
	@FloatRange(from = 0)
	public static float calculateRadius(@NonNull final View view) {
<span class="nc" id="L283">		return calculateRadius(view.getWidth(), view.getHeight());</span>
	}

	/**
	 * Calculates the radius of the specified &lt;var&gt;width&lt;/var&gt; and &lt;var&gt;height&lt;/var&gt; dimension for
	 * purpose of circular reveal animation.
	 *
	 * @param width  The width or horizontal distance from which to calculate radius.
	 * @param height The height or vertical distance from which to calculate radius.
	 * @return Calculated radius that may be used as end/start radius for the desired reveal animation.
	 */
	@FloatRange(from = 0)
	public static float calculateRadius(@FloatRange(from = 0) final float width, @FloatRange(from = 0) final float height) {
<span class="nc" id="L296">		return (float) Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));</span>
	}

	/**
	 * Same as {@link #resolveCenterPosition(View, float, float)} with fraction {@code 0.5} for booth
	 * center coordinates.
	 */
	@Size(2)
	@NonNull
	public static float[] resolveCenterPosition(@NonNull final View view) {
<span class="nc" id="L306">		return resolveCenterPosition(view, CENTER_FRACTION, CENTER_FRACTION);</span>
	}

	/**
	 * Like {@link #resolveCenter(View, float, float)} this method will resolve center of the specified
	 * &lt;var&gt;view&lt;/var&gt; based on its current &lt;b&gt;width&lt;/b&gt; and &lt;b&gt;height&lt;/b&gt; but also takes into count
	 * its current &lt;b&gt;x&lt;/b&gt; and &lt;b&gt;y&lt;/b&gt; coordinate.
	 *
	 * @param view            The view of which center position to resolve.
	 * @param centerXFraction Fraction to resolve x coordinate of the center. Should be from the
	 *                        {@code [0.0, 1.0]} range.
	 * @param centerYFraction Fraction to resolve y coordinate of the center. Should be from the
	 *                        {@code [0.0, 1.0]} range.
	 * @return An array with center coordinates: centerX[0], centerY[1].
	 */
	@Size(2)
	@NonNull
	public static float[] resolveCenterPosition(
			@NonNull final View view,
			@FloatRange(from = 0, to = 1) final float centerXFraction,
			@FloatRange(from = 0, to = 1) final float centerYFraction
	) {
<span class="nc" id="L328">		final float[] center = resolveCenter(view, centerXFraction, centerYFraction);</span>
<span class="nc" id="L329">		return new float[]{</span>
<span class="nc" id="L330">				view.getX() + center[0],</span>
<span class="nc" id="L331">				view.getY() + center[1]</span>
		};
	}

	/**
	 * Same as {@link #resolveCenter(View, float, float)} with fraction {@code 0.5} for booth center
	 * coordinates.
	 */
	@Size(2)
	@NonNull
	public static float[] resolveCenter(@NonNull final View view) {
<span class="nc" id="L342">		return resolveCenter(view, CENTER_FRACTION, CENTER_FRACTION);</span>
	}

	/**
	 * Resolves the center of the specified &lt;var&gt;view&lt;/var&gt; based on its current &lt;var&gt;width&lt;/var&gt; and
	 * &lt;b&gt;height&lt;/b&gt; according to the requested fractions.
	 *
	 * @param view            The view of which center to resolve.
	 * @param centerXFraction Fraction to resolve x coordinate of the center. Should be from the
	 *                        {@code [0.0, 1.0]} range.
	 * @param centerYFraction Fraction to resolve y coordinate of the center. Should be from the
	 *                        {@code [0.0, 1.0]} range.
	 * @return An array with center coordinates: centerX[0], centerY[1].
	 */
	@Size(2)
	@NonNull
	public static float[] resolveCenter(
			@NonNull final View view,
			@FloatRange(from = 0, to = 1) final float centerXFraction,
			@FloatRange(from = 0, to = 1) final float centerYFraction
	) {
<span class="nc" id="L363">		return new float[]{</span>
<span class="nc" id="L364">				view.getWidth() * centerXFraction,</span>
<span class="nc" id="L365">				view.getHeight() * centerYFraction</span>
		};
	}

	/**
	 * Same as {@link #createAnimator(View, int, int, float, float)} where the center coordinates
	 * will be automatically resolved using the given &lt;var&gt;view&lt;/var&gt;.
	 *
	 * @see #resolveCenterPosition(View)
	 */
	@NonNull
	public static Animator createAnimator(
			@NonNull final View view,
			@FloatRange(from = 0) final float startRadius,
			@FloatRange(from = 0) final float endRadius
	) {
<span class="nc" id="L381">		final float[] center = resolveCenterPosition(view);</span>
<span class="nc" id="L382">		return createAnimator(view, Math.round(center[0]), Math.round(center[1]), startRadius, endRadius);</span>
	}

	/**
	 * Creates a new instance of circular reveal Animator for the specified &lt;var&gt;view&lt;/var&gt;.
	 *
	 * @param view        The view for which to create the requested animator.
	 * @param centerX     X coordinate of a center from where should the reveal animation start.
	 * @param centerY     Y coordinate of a center from where should the reveal animation start.
	 * @param startRadius Radius of the specified view at the start of the reveal animation.
	 * @param endRadius   Radius of the specified view at the end of the reveal animation.
	 * @return Animator that will play circular reveal animation for the specified view according
	 * to the specified parameters when started.
	 * @see ViewAnimationUtils#createCircularReveal(View, int, int, float, float)
	 */
	@NonNull
	public static Animator createAnimator(
			@NonNull final View view,
			@IntRange(from = 0) final int centerX,
			@IntRange(from = 0) final int centerY,
			@FloatRange(from = 0) final float startRadius,
			@FloatRange(from = 0) final float endRadius
	) {
<span class="nc" id="L405">		return ViewAnimationUtils.createCircularReveal(view, centerX, centerY, startRadius, endRadius);</span>
	}

	/**
	 * Sets a mode in which should this transition run.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link #REVEAL}&lt;/b&gt;
	 *
	 * @param mode The desired mode. One of {@link #REVEAL} or {@link #CONCEAL}.
	 * @see #getMode()
	 */
	@Override
	public final void setMode(@RevealMode final int mode) {
<span class="nc" id="L418">		this.mMode = mode;</span>
<span class="nc" id="L419">	}</span>

	/**
	 * Returns the reveal mode of this transition.
	 *
	 * @return One of {@link #REVEAL} or {@link #CONCEAL}.
	 */
	@RevealMode
	public final int getMode() {
<span class="nc" id="L428">		return mMode;</span>
	}

	/**
	 * Sets a start radius for animating circle of the reveal animation. Based on the current reveal
	 * mode, this radius should be either smaller than the end radius specified via {@link #setEndRadius(Float)}
	 * or grater one otherwise there will be nothing to reveal/conceal.
	 *
	 * @param radius The desired radius in pixels. May be {@code null} to use the default approach
	 *               to compute start radius based on the reveal mode.
	 * @see R.attr#uiStartRadius ui:uiStartRadius
	 * @see #getStartRadius()
	 * @see #setEndRadius(Float)
	 */
	public void setStartRadius(@Nullable final Float radius) {
<span class="nc" id="L443">		this.mStartRadius = radius;</span>
<span class="nc" id="L444">	}</span>

	/**
	 * Returns the start radius for animating circle of the reveal animation.
	 *
	 * @return Start radius in pixels or {@code null} if this radius will be calculated based on the
	 * reveal mode.
	 * @see #setStartRadius(Float)
	 */
	@Nullable
	public Float getStartRadius() {
<span class="nc" id="L455">		return mStartRadius;</span>
	}

	/**
	 * Sets an end radius for animating circle of the reveal animation. Based on the current reveal
	 * mode, this radius should be either greater than the start radius specified via {@link #setStartRadius(Float)}
	 * or smaller one otherwise there will be nothing to reveal/conceal.
	 *
	 * @param radius The desired radius in pixels. May be {@code null} to use the default approach
	 *               to compute end radius based on the reveal mode.
	 * @see R.attr#uiEndRadius ui:uiEndRadius
	 * @see #getEndRadius()
	 * @see #setStartRadius(Float)
	 */
	public void setEndRadius(@Nullable final Float radius) {
<span class="nc" id="L470">		this.mEndRadius = radius;</span>
<span class="nc" id="L471">	}</span>

	/**
	 * Returns the end radius for animating circle of the reveal animation.
	 *
	 * @return End radius in pixels or {@code null} if this radius will be calculated based on the
	 * reveal mode.
	 * @see #setEndRadius(Float)
	 */
	@Nullable
	public Float getEndRadius() {
<span class="nc" id="L482">		return mEndRadius;</span>
	}

	/**
	 * Sets a visibility flag that should be set to a revealing view whenever this transition starts.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link View#VISIBLE VISIBLE}&lt;/b&gt;
	 *
	 * @param visibility One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see R.attr#uiStartVisibility ui:uiStartVisibility
	 * @see #getStartVisibility()
	 */
	public void setStartVisibility(final int visibility) {
<span class="nc" id="L495">		this.mStartVisibility = visibility;</span>
<span class="nc" id="L496">	}</span>

	/**
	 * Returns the visibility flag that will be set to a revealing view whenever this transition
	 * (its animation) starts.
	 *
	 * @return One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see #setStartVisibility(int)
	 */
	public int getStartVisibility() {
<span class="nc" id="L506">		return mStartVisibility;</span>
	}

	/**
	 * Sets a visibility flag that should be set to a revealing view whenever this transition
	 * (its animation) ends.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link View#VISIBLE VISIBLE}&lt;/b&gt;
	 *
	 * @param visibility One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see R.attr#uiEndVisibility ui:uiEndVisibility
	 * @see #getEndVisibility()
	 */
	public void setEndVisibility(final int visibility) {
<span class="nc" id="L520">		this.mEndVisibility = visibility;</span>
<span class="nc" id="L521">	}</span>

	/**
	 * Returns the visibility flag that will be set to a revealing view whenever this transition ends.
	 *
	 * @return One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see #setEndVisibility(int)
	 */
	public int getEndVisibility() {
<span class="nc" id="L530">		return mEndVisibility;</span>
	}

	/**
	 * Sets a visibility flag that should be set to a revealing view whenever this transition has
	 * been requested to create an appear animator via {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link View#VISIBLE VISIBLE}&lt;/b&gt;
	 *
	 * @param visibility One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see R.attr#uiAppearVisibility ui:uiAppearVisibility
	 * @see #getAppearVisibility()
	 */
	public void setAppearVisibility(final int visibility) {
<span class="nc" id="L544">		this.mAppearVisibility = visibility;</span>
<span class="nc" id="L545">	}</span>

	/**
	 * Returns the visibility flag that will be set to a revealing view whenever this transition is
	 * requested to create an appear animator.
	 *
	 * @return One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see #setAppearVisibility(int)
	 */
	public int getAppearVisibility() {
<span class="nc" id="L555">		return mAppearVisibility;</span>
	}

	/**
	 * Sets a visibility flag that should be set to a revealing view whenever this transition has
	 * been requested to create a disappear animator via {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link View#VISIBLE VISIBLE}&lt;/b&gt;
	 *
	 * @param visibility One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see R.attr#uiDisappearVisibility ui:uiDisappearVisibility
	 * @see #getDisappearVisibility()
	 */
	public void setDisappearVisibility(final int visibility) {
<span class="nc" id="L569">		this.mDisappearVisibility = visibility;</span>
<span class="nc" id="L570">	}</span>

	/**
	 * Returns the visibility flag that will be set to a revealing view whenever this transition is
	 * requested to created a disappear animator.
	 *
	 * @return One of {@link View#VISIBLE}, {@link View#INVISIBLE} or {@link View#GONE}.
	 * @see #setDisappearVisibility(int)
	 */
	public int getDisappearVisibility() {
<span class="nc" id="L580">		return mDisappearVisibility;</span>
	}

	/**
	 * Sets a gravity flags that should be used to resolve center for animating circle of the reveal
	 * animation.
	 * &lt;p&gt;
	 * Sometimes the gravity is not enough to specify exact center coordinates for the reveal animation.
	 * In such case you can move the center coordinates calculated by the requested gravity by
	 * specifying horizontal and vertical offset via {@link #setCenterHorizontalOffset(int)} and
	 * {@link #setCenterVerticalOffset(int)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code null}&lt;/b&gt;
	 *
	 * @param gravity One of {@link Gravity#CENTER}, {@link Gravity#CENTER_VERTICAL}, {@link Gravity#CENTER_HORIZONTAL},
	 *                {@link Gravity#TOP}, {@link Gravity#BOTTOM}, {@link Gravity#START}, {@link Gravity#END}
	 *                or theirs combination. May be {@code null} to use either specified exact center
	 *                coordinates or the specified fractions to calculate such coordinates.
	 * @see R.attr#uiCenterGravity ui:uiCenterGravity
	 * @see #getCenterGravity()
	 * @see #setCenterX(Float)
	 * @see #setCenterY(Float)
	 * @see #setCenterXFraction(float)
	 * @see #setCenterYFraction(float)
	 */
	public void setCenterGravity(@Nullable final Integer gravity) {
<span class="nc" id="L606">		this.mCenterGravity = gravity;</span>
<span class="nc" id="L607">	}</span>

	/**
	 * Returns the gravity flags that will be used to resolve center for animating circle of the
	 * reveal animation.
	 *
	 * @return One of {@link Gravity#CENTER}, {@link Gravity#CENTER_VERTICAL}, {@link Gravity#CENTER_HORIZONTAL},
	 * {@link Gravity#TOP}, {@link Gravity#BOTTOM}, {@link Gravity#START}, {@link Gravity#END} or
	 * theirs combination or {@code null} if no gravity has been specified so either center coordinates
	 * specified via {@link #setCenterX(Float)} and {@link #setCenterY(Float)} will be used or calculated
	 * using the current center fraction values.
	 * @see #setCenterGravity(Integer)
	 */
	@Nullable
	public Integer getCenterGravity() {
<span class="nc" id="L622">		return mCenterGravity;</span>
	}

	/**
	 * Sets an offset for the &lt;b&gt;center x&lt;/b&gt; coordinate for animating circle of the reveal animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code 0}&lt;/b&gt;
	 *
	 * @param offset The desired offset in pixels. If negative the center x coordinate will be moved
	 *               the the left, if positive it will be moved to the right, otherwise remains
	 *               unchanged.
	 * @see R.attr#uiCenterHorizontalOffset ui:uiCenterHorizontalOffset
	 * @see #getCenterHorizontalOffset()
	 * @see #setCenterVerticalOffset(int)
	 */
	public void setCenterHorizontalOffset(final int offset) {
<span class="nc" id="L638">		this.mCenterHorizontalOffset = offset;</span>
<span class="nc" id="L639">	}</span>

	/**
	 * Returns the offset for the &lt;b&gt;center x&lt;/b&gt; coordinate for animating circle of the reveal animation.
	 *
	 * @return Horizontal offset in pixels.
	 * @see #setCenterHorizontalOffset(int)
	 */
	public int getCenterHorizontalOffset() {
<span class="nc" id="L648">		return mCenterHorizontalOffset;</span>
	}

	/**
	 * Sets an offset for the &lt;b&gt;center y&lt;/b&gt; coordinate for animating circle of the reveal animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code 0}&lt;/b&gt;
	 *
	 * @param offset The desired offset in pixels. If negative the center y coordinate will be moved
	 *               the the top, if positive it will be moved to the bottom, otherwise remains
	 *               unchanged.
	 * @see R.attr#uiCenterVerticalOffset ui:uiCenterVerticalOffset
	 * @see #getCenterVerticalOffset()
	 * @see #setCenterHorizontalOffset(int)
	 */
	public void setCenterVerticalOffset(final int offset) {
<span class="nc" id="L664">		this.mCenterVerticalOffset = offset;</span>
<span class="nc" id="L665">	}</span>

	/**
	 * Returns the offset for the &lt;b&gt;center y&lt;/b&gt; coordinate for animating circle of the reveal animation.
	 *
	 * @return Vertical offset in pixels.
	 * @see #setCenterVerticalOffset(int)
	 */
	public int getCenterVerticalOffset() {
<span class="nc" id="L674">		return mCenterVerticalOffset;</span>
	}

	/**
	 * Sets a center x coordinate for animating circle of the reveal animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code null}&lt;/b&gt;
	 *
	 * @param centerX The desired center x coordinate in pixels. May be {@code null} to use center
	 *                x fraction specified via {@link #setCenterXFraction(float)} instead.
	 * @see #getCenterX()
	 * @see #setCenterXFraction(float)
	 * @see #setCenterY(Float)
	 */
	public void setCenterX(@Nullable final Float centerX) {
<span class="nc" id="L689">		this.mCenterX = centerX;</span>
<span class="nc" id="L690">	}</span>

	/**
	 * Returns the x coordinate of the center for animating circle of the reveal animation.
	 *
	 * @return X coordinate of the center for animating circle in pixels or {@code null} if no coordinate
	 * has been specified so the fraction will be used to calculate this center coordinate.
	 * @see #setCenterX(Float)
	 */
	@Nullable
	public Float getCenterX() {
<span class="nc" id="L701">		return mCenterX;</span>
	}

	/**
	 * Sets a center y coordinate for animating circle of the reveal animation.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code null}&lt;/b&gt;
	 *
	 * @param centerY The desired center y coordinate in pixels. May be {@code null} to use center
	 *                y fraction specified via {@link #setCenterYFraction(float)} instead.
	 * @see #getCenterY()
	 * @see #setCenterYFraction(float)
	 * @see #setCenterX(Float)
	 */
	public void setCenterY(@Nullable final Float centerY) {
<span class="nc" id="L716">		this.mCenterY = centerY;</span>
<span class="nc" id="L717">	}</span>

	/**
	 * Returns the y coordinate of the center for animating circle of the reveal animation.
	 *
	 * @return Y coordinate of the center for animating circle in pixels or {@code null} if no coordinate
	 * has been specified so the fraction will be used to calculate this center coordinate.
	 * @see #setCenterY(Float)
	 */
	@Nullable
	public Float getCenterY() {
<span class="nc" id="L728">		return mCenterY;</span>
	}

	/**
	 * Sets a fraction for the &lt;b&gt;center x&lt;/b&gt; coordinate. This fraction will be used to resolve
	 * center x coordinate of an animating view depending on its current &lt;b&gt;width&lt;/b&gt; if such value
	 * has not been specified via {@link #setCenterX(Float)}.
	 * &lt;p&gt;
	 * Sometimes the fraction is not enough to specify exact center coordinate for the reveal animation.
	 * In such case you can move the center coordinates calculated by the requested fractions by
	 * specifying horizontal and vertical offset via {@link #setCenterHorizontalOffset(int)} and
	 * {@link #setCenterVerticalOffset(int)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code 0.5}&lt;/b&gt;
	 *
	 * @param fractionX The desired fraction from the {@code [0.0, 1.0]} range.
	 * @see android.R.attr#centerX android:centerX
	 * @see #getCenterXFraction()
	 * @see #setCenterYFraction(float)
	 * @see #setCenterX(Float)
	 */
	public void setCenterXFraction(@FloatRange(from = 0, to = 1) final float fractionX) {
<span class="nc" id="L750">		this.mCenterXFraction = fractionX;</span>
<span class="nc" id="L751">	}</span>

	/**
	 * Returns the fraction of the &lt;b&gt;center x&lt;/b&gt; coordinate.
	 *
	 * @return Fraction from the {@code [0.0, 1.0]} range.
	 * @see #setCenterXFraction(float)
	 */
	@FloatRange(from = 0, to = 1)
	public float getCenterXFraction() {
<span class="nc" id="L761">		return mCenterXFraction;</span>
	}

	/**
	 * Sets a fraction for the &lt;b&gt;center y&lt;/b&gt; coordinate. This fraction will be used to resolve
	 * center y coordinate of an animating view depending on its current &lt;b&gt;height&lt;/b&gt; if such value
	 * has not been specified via {@link #setCenterY(Float)}.
	 * &lt;p&gt;
	 * Sometimes the fraction is not enough to specify exact center coordinate for the reveal animation.
	 * In such case you can move the center coordinates calculated by the requested fractions by
	 * specifying horizontal and vertical offset via {@link #setCenterHorizontalOffset(int)} and
	 * {@link #setCenterVerticalOffset(int)}.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code 0.5}&lt;/b&gt;
	 *
	 * @param fractionY The desired fraction from the {@code [0.0, 1.0]} range.
	 * @see android.R.attr#centerY android:centerY
	 * @see #getCenterYFraction()
	 * @see #setCenterXFraction(float)
	 * @see #setCenterY(Float)
	 */
	public void setCenterYFraction(@FloatRange(from = 0, to = 1) final float fractionY) {
<span class="nc" id="L783">		this.mCenterYFraction = fractionY;</span>
<span class="nc" id="L784">	}</span>

	/**
	 * Returns the fraction of the &lt;b&gt;center y&lt;/b&gt; coordinate.
	 *
	 * @return Fraction from the {@code [0.0, 1.0]} range.
	 * @see #setCenterYFraction(float)
	 */
	@FloatRange(from = 0, to = 1)
	public float getCenterYFraction() {
<span class="nc" id="L794">		return mCenterYFraction;</span>
	}

	/**
	 */
	@Override
	public Animator onAppear(final ViewGroup sceneRoot, final View view, final TransitionValues startValues, final TransitionValues endValues) {
<span class="nc" id="L801">		calculateTransitionProperties(view);</span>
<span class="nc" id="L802">		final Animator animator = createAnimatorFromInfo(view);</span>
<span class="nc" id="L803">		animator.addListener(new AnimatorListenerAdapter() {</span>

			/**
			 */
			@Override
			public void onAnimationStart(Animator animation) {
<span class="nc" id="L809">				view.setVisibility(mStartVisibility);</span>
<span class="nc" id="L810">			}</span>

			/**
			 */
			@Override
			public void onAnimationEnd(Animator animation) {
<span class="nc" id="L816">				view.setVisibility(mEndVisibility);</span>
<span class="nc" id="L817">			}</span>
		});
<span class="nc" id="L819">		view.setVisibility(mAppearVisibility);</span>
<span class="nc" id="L820">		return animator;</span>
	}

	/**
	 */
	@Override
	public Animator onDisappear(final ViewGroup sceneRoot, final View view, final TransitionValues startValues, final TransitionValues endValues) {
<span class="nc" id="L827">		calculateTransitionProperties(view);</span>
<span class="nc" id="L828">		final Animator animator = createAnimatorFromInfo(view);</span>
<span class="nc" id="L829">		animator.addListener(new AnimatorListenerAdapter() {</span>

			/**
			 */
			@Override
			public void onAnimationStart(Animator animation) {
<span class="nc" id="L835">				view.setVisibility(mStartVisibility);</span>
<span class="nc" id="L836">			}</span>

			/**
			 */
			@Override
			public void onAnimationEnd(Animator animation) {
<span class="nc" id="L842">				view.setVisibility(mEndVisibility);</span>
<span class="nc" id="L843">			}</span>
		});
<span class="nc" id="L845">		view.setVisibility(mDisappearVisibility);</span>
<span class="nc" id="L846">		return animator;</span>
	}

	/**
	 * Ensures that all necessary properties for this transition are calculated.
	 *
	 * @param view The view to which will be the transition applied.
	 */
	private void calculateTransitionProperties(final View view) {
		// First calculate center of the reveal transition.
		final float[] center;
<span class="nc bnc" id="L857" title="All 2 branches missed.">		if (mCenterGravity == null) {</span>
<span class="nc" id="L858">			center = resolveCenter(view, mCenterXFraction, mCenterYFraction);</span>
		} else {
<span class="nc" id="L860">			center = resolveGravityCenter(view);</span>
		}
<span class="nc bnc" id="L862" title="All 2 branches missed.">		final float centerX = mCenterX == null ? center[0] : mCenterX;</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">		final float centerY = mCenterY == null ? center[1] : mCenterY;</span>
<span class="nc" id="L864">		mInfo.centerX = centerX + mCenterHorizontalOffset;</span>
<span class="nc" id="L865">		mInfo.centerY = centerY + mCenterVerticalOffset;</span>
		// Now calculate start with end radius of the reveal transition.
<span class="nc" id="L867">		final float[] radii = calculateTransitionRadii(view);</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">		mInfo.startRadius = mStartRadius == null ? radii[0] : mStartRadius;</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">		mInfo.endRadius = mEndRadius == null ? radii[1] : mEndRadius;</span>
<span class="nc" id="L870">	}</span>

	/**
	 * Resolves center coordinates for the reveal animation of the specified &lt;var&gt;view&lt;/var&gt; depending
	 * on the current value of {@link #mCenterGravity}.
	 *
	 * @param view The view for which will be the reveal animation run.
	 * @return An array with center coordinates: centerX[0], centerY[1].
	 */
	@SuppressLint(&quot;RtlHardcoded&quot;)
	private float[] resolveGravityCenter(final View view) {
<span class="nc" id="L881">		final float[] center = new float[]{0, 0};</span>
<span class="nc" id="L882">		final int viewWidth = view.getWidth();</span>
<span class="nc" id="L883">		final int viewHeight = view.getHeight();</span>
<span class="nc" id="L884">		final int layoutDirection = view.getLayoutDirection();</span>
<span class="nc" id="L885">		final int absoluteGravity = Gravity.getAbsoluteGravity(mCenterGravity, layoutDirection);</span>
<span class="nc" id="L886">		final int horizontalGravity = absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK;</span>
<span class="nc" id="L887">		final int verticalGravity = mCenterGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span>
		// Resolve center horizontal coordinate.
<span class="nc bnc" id="L889" title="All 3 branches missed.">		switch (horizontalGravity) {</span>
			case Gravity.CENTER_HORIZONTAL:
<span class="nc" id="L891">				center[0] = viewWidth / 2f;</span>
<span class="nc" id="L892">				break;</span>
			case Gravity.RIGHT:
<span class="nc" id="L894">				center[0] = viewWidth;</span>
<span class="nc" id="L895">				break;</span>
			case Gravity.LEFT:
			default:
<span class="nc" id="L898">				center[0] = 0;</span>
				break;
		}
		// Resolve center vertical coordinate.
<span class="nc bnc" id="L902" title="All 3 branches missed.">		switch (verticalGravity) {</span>
			case Gravity.CENTER_VERTICAL:
<span class="nc" id="L904">				center[1] = viewHeight / 2f;</span>
<span class="nc" id="L905">				break;</span>
			case Gravity.BOTTOM:
<span class="nc" id="L907">				center[1] = viewHeight;</span>
<span class="nc" id="L908">				break;</span>
			case Gravity.TOP:
			default:
<span class="nc" id="L911">				center[1] = 0;</span>
				break;
		}
<span class="nc" id="L914">		return center;</span>
	}

	/**
	 * Calculates start and end radius for the reveal animation of the specified &lt;var&gt;view&lt;/var&gt;
	 * depending on the current {@link #mMode}.
	 *
	 * @param view The view for which reveal animation to calculate start and end radius.
	 * @return An array with two radii: startRadius[0], endRadius[1].
	 */
	private float[] calculateTransitionRadii(final View view) {
		final float startRadius;
		final float endRadius;
<span class="nc bnc" id="L927" title="All 2 branches missed.">		switch (mMode) {</span>
			case CONCEAL:
<span class="nc" id="L929">				startRadius = calculateTransitionRadius(view);</span>
<span class="nc" id="L930">				endRadius = 0;</span>
<span class="nc" id="L931">				break;</span>
			case REVEAL:
			default:
<span class="nc" id="L934">				startRadius = 0;</span>
<span class="nc" id="L935">				endRadius = calculateTransitionRadius(view);</span>
				break;
		}
<span class="nc" id="L938">		return new float[]{startRadius, endRadius};</span>
	}

	/**
	 * Calculates radius for the reveal transition for the specified &lt;var&gt;view&lt;/var&gt;.
	 * The radius is calculated depending on how big distance should be traveled from the current
	 * center coordinates to the outermost edge of the given view.
	 * &lt;p&gt;
	 * &lt;b&gt;Note, that this method assumes that center coordinates for the reveal transitions has
	 * been already calculated and are presented in {@link #mInfo}&lt;/b&gt;.
	 *
	 * @param view The view for which reveal animation to calculate the requested radius.
	 * @return Calculated radius that should be used as end/start radius for reveal animation
	 * depends on its current mode.
	 */
	private float calculateTransitionRadius(final View view) {
		final float horizontalDistance;
		final float verticalDistance;
<span class="nc" id="L956">		final float centerX = mInfo.centerX;</span>
<span class="nc" id="L957">		final float centerY = mInfo.centerY;</span>
<span class="nc" id="L958">		final float viewWidth = view.getWidth();</span>
<span class="nc" id="L959">		final float viewHeight = view.getHeight();</span>
<span class="nc" id="L960">		final float[] viewCenter = resolveCenter(view);</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">		if (centerX &gt;= viewCenter[0]) {</span>
<span class="nc" id="L962">			horizontalDistance = centerX / viewWidth * viewWidth;</span>
		} else {
<span class="nc" id="L964">			horizontalDistance = (1 - (centerX / viewWidth)) * viewWidth;</span>
		}
<span class="nc bnc" id="L966" title="All 2 branches missed.">		if (centerY &gt;= viewCenter[1]) {</span>
<span class="nc" id="L967">			verticalDistance = centerY / viewHeight * viewHeight;</span>
		} else {
<span class="nc" id="L969">			verticalDistance = (1 - (centerY / viewHeight)) * viewHeight;</span>
		}
<span class="nc" id="L971">		return calculateRadius(horizontalDistance, verticalDistance);</span>
	}

	/**
	 * Creates a new instance of circular reveal Animator for the specified &lt;var&gt;view&lt;/var&gt; with current
	 * reveal properties specified within {@link #mInfo}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note, that this animator will be already wrapped in {@link AnimatorWrapper} which will have
	 * PAUSE and RESUME features disabled to ensure that there will be no exception thrown by the
	 * Android system if it tries to pause already running Reveal transition where such situation
	 * is not properly handled by the system at this time.&lt;/b&gt;
	 *
	 * @param view The view for which to create the requested animator.
	 * @return Animator that will play circular reveal animation when started.
	 */
	private Animator createAnimatorFromInfo(final View view) {
<span class="nc" id="L987">		final Animator animator = createAnimator(</span>
				view,
<span class="nc" id="L989">				Math.round(mInfo.centerX),</span>
<span class="nc" id="L990">				Math.round(mInfo.centerY),</span>
				mInfo.startRadius,
				mInfo.endRadius
		);
<span class="nc" id="L994">		final AnimatorWrapper animatorWrapper = new AnimatorWrapper(animator);</span>
<span class="nc" id="L995">		animatorWrapper.removeFeature(AnimatorWrapper.PAUSE | AnimatorWrapper.RESUME);</span>
<span class="nc" id="L996">		return animatorWrapper;</span>
	}

	/*
	 * Inner classes ===============================================================================
	 */

	/**
	 * Class holding necessary values for the reveal transition that are exclusively associated with
	 * the currently transitioning view.
	 */
<span class="nc" id="L1007">	private static final class Info {</span>

		/**
		 * Reveal circle radius.
		 */
		float startRadius, endRadius;

		/**
		 * Reveal circle center coordinate.
		 */
		float centerX, centerY;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>