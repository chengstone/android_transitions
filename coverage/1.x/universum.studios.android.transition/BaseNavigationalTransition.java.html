<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BaseNavigationalTransition.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.transition</a> &gt; <span class="el_source">BaseNavigationalTransition.java</span></div><h1>BaseNavigationalTransition.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License
 * you may obtain at
 *
 * 		http://www.apache.org/licenses/LICENSE-2.0
 *
 * You can redistribute, modify or publish any part of the code written within this file but as it
 * is described in the License, the software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.transition;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.ActivityOptions;
import android.app.Fragment;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.support.annotation.IntRange;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.transition.Transition;
import android.transition.TransitionInflater;
import android.transition.TransitionManager;
import android.util.Pair;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * BaseNavigationalTransition represents a simple wrapper around window {@link Transition Transitions}
 * framework to simplify and also to made transitioning between two {@link Activity Activities}
 * independent from the current Android version, that is, to hide such transitions implementation
 * from the context where it is used.
 * &lt;p&gt;
 * A specific navigational transition implementation may be associated with its corresponding activity
 * class that can be supplied to {@link #BaseNavigationalTransition(Class)} constructor. This class
 * is used to create an instance of Intent that will be by default started whenever {@link #start(Activity)}
 * is invoked. Both {@link #onStart(Activity)} and {@link #onFinish(Activity)} methods cen be overridden
 * by a specific transition implementations to match theirs specific needs.
 *
 * &lt;h3&gt;Sample&lt;/h3&gt;
 * &lt;pre&gt;
 * public abstract class DetailTransition extends BaseNavigationalTransition {
 *
 *     DetailTransition() {
 *         super(DetailActivity.class);
 *     }
 *
 *     &amp;#64;NonNull
 *     public static DetailTransition get() {
 *          return UiConfig.MATERIAL_SUPPORT ? new MaterialTransition() : new DefaultTransition();
 *     }
 *
 *     &amp;#64;Override
 *     public Intent createIntent(&amp;#64;NonNull Activity caller) {
 *         final Intent intent = super.createIntent(caller);
 *         // ... put here any extras that need to be delivered to the called activity
 *         return intent;
 *     }
 *
 *     static final class DefaultTransition extends DetailTransition {
 *
 *          &amp;#64;Override
 *          protected void onStart(&amp;#64;NonNull Activity caller) {
 *              super.onStart(caller);
 *              // ... change activities with custom window animation
 *              WindowTransition.overrideStart(caller);
 *          }
 *
 *          &amp;#64;Override
 *          protected void onFinish(&amp;#64;NonNull Activity caller) {
 *              super.onFinish(caller);
 *              // ... change activities without animation
 *              caller.overridePendingTransition(0, 0);
 *          }
 *     }
 *
 *     // ... other implementations specific for a different platform versions
 *
 *     static final class MaterialTransition extends DetailTransition {
 *
 *          &amp;#64;Override
 *          protected void onStart(&amp;#64;NonNull Activity caller) {
 *              // ... made some modifications to the caller's UI (if necessary) before the transitions
 *              // ... are triggered.
 *              super.onStart(caller);
 *          }
 *
 *          &amp;#64;Override
 *          protected void onFinish(&amp;#64;NonNull Activity caller) {
 *              super.onFinish(caller);
 *              // ... no need to override in most cases
 *          }
 *     }
 * }
 * &lt;/pre&gt;
 *
 * @author Martin Albedinsky
 */
public abstract class BaseNavigationalTransition&lt;T extends BaseNavigationalTransition&gt; {

	/*
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	//private static final String TAG = &quot;BaseNavigationalTransition&quot;;

	/**
	 * Boolean flag indicating whether the current Android device can run Material Design like navigational
	 * transition (i. e. with shared elements, ...) or not.
	 */
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">	public static final boolean MATERIAL_SUPPORT = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;</span>

	/**
	 * Flag determining that no request code has been specified for a specific navigational transition.
	 */
	public static final int RC_NONE = -1;

	/**
	 * Flag determining whether an &lt;b&gt;enter&lt;/b&gt; transition has been specified via
	 * {@link #enterTransition(Transition)} or ot.
	 */
	private static final int TRANSITION_ENTER = 0x00000001;

	/**
	 * Flag determining whether a &lt;b&gt;reenter&lt;/b&gt; transition has been specified via
	 * {@link #reenterTransition(Transition)} or ot.
	 */
	private static final int TRANSITION_REENTER = 0x00000001 &lt;&lt; 1;

	/**
	 * Flag determining whether a &lt;b&gt;return&lt;/b&gt; transition has been specified via
	 * {@link #returnTransition(Transition)} or ot.
	 */
	private static final int TRANSITION_RETURN = 0x00000001 &lt;&lt; 2;

	/**
	 * Flag determining whether an &lt;b&gt;exit&lt;/b&gt; transition has been specified via
	 * {@link #exitTransition(Transition)} or ot.
	 */
	private static final int TRANSITION_EXIT = 0x00000001 &lt;&lt; 3;

	/**
	 * Flag determining whether a shared element's &lt;b&gt;enter&lt;/b&gt; transition has been specified via
	 * {@link #sharedElementEnterTransition(Transition)} or ot.
	 */
	private static final int TRANSITION_SHARED_ELEMENT_ENTER = 0x00000001 &lt;&lt; 4;

	/**
	 * Flag determining whether a shared element's &lt;b&gt;reenter&lt;/b&gt; transition has been specified via
	 * {@link #sharedElementReenterTransition(Transition)} or ot.
	 */
	private static final int TRANSITION_SHARED_ELEMENT_REENTER = 0x00000001 &lt;&lt; 5;

	/**
	 * Flag determining whether a shared element's &lt;b&gt;return&lt;/b&gt; transition has been specified via
	 * {@link #sharedElementReturnTransition(Transition)} or ot.
	 */
	private static final int TRANSITION_SHARED_ELEMENT_RETURN = 0x00000001 &lt;&lt; 6;

	/**
	 * Flag determining whether a shared element's &lt;b&gt;exit&lt;/b&gt; transition has been specified via
	 * {@link #sharedElementExitTransition(Transition)} or ot.
	 */
	private static final int TRANSITION_SHARED_ELEMENT_EXIT = 0x00000001 &lt;&lt; 7;

	/*
	 * Interface ===================================================================================
	 */

	/*
	 * Static members ==============================================================================
	 */

	/*
	 * Members =====================================================================================
	 */

	/**
	 * Class of activity that should be started as new Intent whenever this navigational transition
	 * is started via {@link #start(Activity)}.
	 */
	protected final Class&lt;? extends Activity&gt; mClassOfTransitionActivity;

	/**
	 * Bundle containing extras for the activity transition activity.
	 */
	private Bundle mIntentExtras;

	/**
	 * If set (other than {@link #RC_NONE}) starting of intent specific for this navigational transition
	 * will be performed via {@link Activity#startActivityForResult(Intent, int)}, {@link Activity#startActivityForResult(Intent, int, Bundle)}
	 * or {@link Fragment#startActivityForResult(Intent, int)} depends on the type of caller and
	 * current configuration of this transition.
	 */
<span class="fc" id="L214">	int mRequestCode = RC_NONE;</span>

	/**
	 * Transition that should be attached to caller's activity window if {@link #TRANSITION_ENTER}
	 * flag is contained within {@link #mSpecifiedTransitions} flags.
	 *
	 * @see Window#setEnterTransition(Transition)
	 */
	private Transition mEnterTransition;

	/**
	 * Transition that should be attached to caller's activity window if {@link #TRANSITION_REENTER}
	 * flag is contained within {@link #mSpecifiedTransitions} flags.
	 *
	 * @see Window#setReenterTransition(Transition)
	 */
	private Transition mReenterTransition;

	/**
	 * Transition that should be attached to caller's activity window if {@link #TRANSITION_RETURN}
	 * flag is contained within {@link #mSpecifiedTransitions} flags.
	 *
	 * @see Window#setReturnTransition(Transition)
	 */
	private Transition mReturnTransition;

	/**
	 * Transition that should be attached to caller's activity window if {@link #TRANSITION_EXIT}
	 * flag is contained within {@link #mSpecifiedTransitions} flags.
	 *
	 * @see Window#setExitTransition(Transition)
	 */
	private Transition mExitTransition;

	/**
	 * Transition for shared element that should be attached to caller's activity window if
	 * {@link #TRANSITION_SHARED_ELEMENT_ENTER} flag is contained within {@link #mSpecifiedTransitions} flags.
	 *
	 * @see Window#setSharedElementEnterTransition(Transition)
	 */
	private Transition mSharedElementEnterTransition;

	/**
	 * Transition for shared element that should be attached to caller's activity window if
	 * {@link #TRANSITION_SHARED_ELEMENT_REENTER} flag is contained within {@link #mSpecifiedTransitions} flags.
	 *
	 * @see Window#setSharedElementReenterTransition(Transition)
	 */
	private Transition mSharedElementReenterTransition;

	/**
	 * Transition for shared element that should be attached to caller's activity window if
	 * {@link #TRANSITION_SHARED_ELEMENT_RETURN} flag is contained within {@link #mSpecifiedTransitions} flags.
	 *
	 * @see Window#setSharedElementReturnTransition(Transition)
	 */
	private Transition mSharedElementReturnTransition;

	/**
	 * Transition for shared element that should be attached to caller's activity window if
	 * {@link #TRANSITION_SHARED_ELEMENT_EXIT} flag is contained within {@link #mSpecifiedTransitions} flags.
	 *
	 * @see Window#setSharedElementExitTransition(Transition)
	 */
	private Transition mSharedElementExitTransition;

	/**
	 * Transition flags determining which transitions has been specified for this navigational transition.
	 */
	private int mSpecifiedTransitions;

	/**
	 * Boolean flag indicating whether an &lt;b&gt;enter&lt;/b&gt; transition can overlap or not.
	 */
	private Boolean mAllowEnterTransitionOverlap;

	/**
	 * Boolean flag indicating whether an &lt;b&gt;return&lt;/b&gt; transition can overlap or not.
	 */
	private Boolean mAllowReturnTransitionOverlap;

	/**
	 * List containing all shared elements specified for this navigational transition. If not empty,
	 * these elements should be transferred to the called activity through Bundle created from
	 * ActivityOptions that can be created via {@link #makeSceneTransitionAnimation(Activity)}.
	 */
	private List&lt;Pair&lt;View, String&gt;&gt; mSharedElements;

	/**
	 * Boolean flag indicating whether transitioning shared elements should use overlay or not.
	 */
	private Boolean mSharedElementUseOverlay;

	/**
	 * Inflater that can be used to inflate a new transition or transition manager.
	 */
	private TransitionInflater mTransitionInflater;

	/*
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of NavigationalTransition without transition activity class.
	 */
<span class="fc" id="L319">	public BaseNavigationalTransition() {</span>
<span class="fc" id="L320">		this.mClassOfTransitionActivity = null;</span>
<span class="fc" id="L321">	}</span>

	/**
	 * Creates a new instance of NavigationalTransition with the specified class of transition activity.
	 *
	 * @param classOfTransitionActivity The activity class that should be used to create a new Intent
	 *                                  that to be started whenever {@link #start(Activity)} is called
	 *                                  upon this navigational transition.
	 */
<span class="fc" id="L330">	public BaseNavigationalTransition(@NonNull final Class&lt;? extends Activity&gt; classOfTransitionActivity) {</span>
<span class="fc" id="L331">		this.mClassOfTransitionActivity = classOfTransitionActivity;</span>
<span class="fc" id="L332">	}</span>

	/*
	 * Methods =====================================================================================
	 */

	/**
	 * Returns the class of activity specified for this navigational transition.
	 *
	 * @return This transitions's associated activity class or {@code null} if not activity class
	 * has been specified.
	 * @see #BaseNavigationalTransition(Class)
	 */
	@Nullable
	public final Class&lt;? extends Activity&gt; getActivityClass() {
<span class="fc" id="L347">		return mClassOfTransitionActivity;</span>
	}

	/**
	 * Specifies a bundle with extras for the &lt;b&gt;incoming&lt;/b&gt; activity. The given bundle will be
	 * attached to this transition's {@link Intent} via {@link Intent#putExtras(Bundle)} when it is
	 * created via {@link #createIntent(Activity)}.
	 *
	 * @param extras The desired bundle with extras. May be {@code null} to clear the current one.
	 * @return This transition to allow methods chaining.
	 * @see #intentExtras()
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T intentExtras(@Nullable final Bundle extras) {
<span class="nc" id="L361">		this.mIntentExtras = extras;</span>
<span class="nc" id="L362">		return (T) this;</span>
	}

	/**
	 * Returns the bundle with extras for the &lt;b&gt;incoming&lt;/b&gt; activity.
	 * &lt;p&gt;
	 * This will be either bundle specified via {@link #intentExtras(Bundle)} or created by default
	 * when this method is called for the first time.
	 *
	 * @return The extras bundle for the &lt;b&gt;incoming&lt;/b&gt; activity.
	 * @see #intentExtras(Bundle)
	 */
	@NonNull
	public Bundle intentExtras() {
<span class="fc bfc" id="L376" title="All 2 branches covered.">		return mIntentExtras == null ? (mIntentExtras = new Bundle()) : mIntentExtras;</span>
	}

	/**
	 * Specifies a request code that should be used to start activity specific for this navigational
	 * transition &lt;b&gt;for result&lt;/b&gt;.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@link #RC_NONE}&lt;/b&gt;
	 *
	 * @param requestCode The desired request code. Can be {@link #RC_NONE} to not start activity
	 *                    for result.
	 * @return This transition to allow methods chaining.
	 * @see #requestCode()
	 * @see Activity#startActivityForResult(Intent, int)
	 * @see Activity#startActivityForResult(Intent, int, Bundle)
	 * @see Fragment#startActivityForResult(Intent, int)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T requestCode(@IntRange(from = RC_NONE) final int requestCode) {
<span class="fc" id="L395">		this.mRequestCode = requestCode;</span>
<span class="fc" id="L396">		return (T) this;</span>
	}

	/**
	 * Returns the request code specified via {@link #requestCode(int)}.
	 *
	 * @return Specified request code or {@link #RC_NONE} by default.
	 */
	@IntRange(from = RC_NONE)
	public int requestCode() {
<span class="fc" id="L406">		return mRequestCode;</span>
	}

	/**
	 * Specifies enter transition to be attached to a window of an &lt;b&gt;incoming&lt;/b&gt; activity.
	 *
	 * @return This transition to allow methods chaining.
	 * @see #enterTransition()
	 * @see Window#setEnterTransition(Transition)
	 * @see #inflateTransition(Context, int)
	 * @see #configureIncomingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T enterTransition(@Nullable final Transition transition) {
<span class="fc" id="L420">		this.mSpecifiedTransitions |= TRANSITION_ENTER;</span>
<span class="fc" id="L421">		this.mEnterTransition = transition;</span>
<span class="fc" id="L422">		return (T) this;</span>
	}

	/**
	 * Returns enter transition for the &lt;b&gt;incoming&lt;/b&gt; activity.
	 *
	 * @return Transition specified via {@link #enterTransition(Transition)} or {@code null} by
	 * default.
	 */
	@Nullable
	public Transition enterTransition() {
<span class="fc" id="L433">		return mEnterTransition;</span>
	}

	/**
	 * Specifies reenter transition to be attached to a window of an &lt;b&gt;outgoing&lt;/b&gt; activity whenever
	 * {@link #start(Activity)} is invoked.
	 *
	 * @return This transition to allow methods chaining.
	 * @see #reenterTransition()
	 * @see Window#setReenterTransition(Transition)
	 * @see #inflateTransition(Context, int)
	 * @see #configureOutgoingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T reenterTransition(@Nullable final Transition transition) {
<span class="fc" id="L448">		this.mSpecifiedTransitions |= TRANSITION_REENTER;</span>
<span class="fc" id="L449">		this.mReenterTransition = transition;</span>
<span class="fc" id="L450">		return (T) this;</span>
	}

	/**
	 * Returns reenter transition for the &lt;b&gt;outgoing&lt;/b&gt; activity.
	 *
	 * @return Transition specified via {@link #reenterTransition(Transition)} or {@code null} by
	 * default.
	 */
	@Nullable
	public Transition reenterTransition() {
<span class="fc" id="L461">		return mReenterTransition;</span>
	}

	/**
	 * Specifies return transition to be attached to a window of an &lt;b&gt;incoming&lt;/b&gt; activity.
	 *
	 * @return This transition to allow methods chaining.
	 * @see #returnTransition()
	 * @see Window#setReturnTransition(Transition)
	 * @see #inflateTransition(Context, int)
	 * @see #configureIncomingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T returnTransition(@Nullable final Transition transition) {
<span class="fc" id="L475">		this.mSpecifiedTransitions |= TRANSITION_RETURN;</span>
<span class="fc" id="L476">		this.mReturnTransition = transition;</span>
<span class="fc" id="L477">		return (T) this;</span>
	}

	/**
	 * Returns return transition for the &lt;b&gt;incoming&lt;/b&gt; activity.
	 *
	 * @return Transition specified via {@link #returnTransition(Transition)} or {@code null} by
	 * default.
	 */
	@Nullable
	public Transition returnTransition() {
<span class="fc" id="L488">		return mReturnTransition;</span>
	}

	/**
	 * Specifies exit transition to be attached to a window of an &lt;b&gt;outgoing&lt;/b&gt; activity whenever
	 * {@link #start(Activity)} is invoked.
	 *
	 * @return This transition to allow methods chaining.
	 * @see #exitTransition()
	 * @see Window#setExitTransition(Transition)
	 * @see #inflateTransition(Context, int)
	 * @see #configureOutgoingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T exitTransition(@Nullable final Transition transition) {
<span class="fc" id="L503">		this.mSpecifiedTransitions |= TRANSITION_EXIT;</span>
<span class="fc" id="L504">		this.mExitTransition = transition;</span>
<span class="fc" id="L505">		return (T) this;</span>
	}

	/**
	 * Returns exit transition for the &lt;b&gt;outgoing&lt;/b&gt; activity.
	 *
	 * @return Transition specified via {@link #exitTransition(Transition)} or {@code null} by
	 * default.
	 */
	@Nullable
	public Transition exitTransition() {
<span class="fc" id="L516">		return mExitTransition;</span>
	}

	/**
	 * Specifies a boolean flag to be set to a window of an &lt;b&gt;incoming&lt;/b&gt; activity in order to
	 * indicate whether enter transition may overlap or not.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code unspecified}&lt;/b&gt;
	 *
	 * @return This transition to allow methods chaining.
	 * @see #allowEnterTransitionOverlap()
	 * @see Window#setAllowEnterTransitionOverlap(boolean)
	 * @see #configureIncomingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T allowEnterTransitionOverlap(final boolean allow) {
<span class="fc" id="L532">		this.mAllowEnterTransitionOverlap = allow;</span>
<span class="fc" id="L533">		return (T) this;</span>
	}

	/**
	 * Returns boolean flag indicating whether enter transition may overlap or not.
	 * &lt;p&gt;
	 * This method returns {@code true} if overlapping has not been specified, which is a default
	 * behaviour of {@link Window#getAllowEnterTransitionOverlap()}.
	 *
	 * @return {@code True} if overlapping of enter transition is enabled, {@code false} otherwise.
	 */
	public boolean allowEnterTransitionOverlap() {
<span class="fc bfc" id="L545" title="All 4 branches covered.">		return mAllowEnterTransitionOverlap == null || mAllowEnterTransitionOverlap;</span>
	}

	/**
	 * Specifies a boolean flag to be set to a window of an &lt;b&gt;incoming&lt;/b&gt; activity in order to
	 * indicate whether return transition may overlap or not.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code unspecified}&lt;/b&gt;
	 *
	 * @return This transition to allow methods chaining.
	 * @see #allowReturnTransitionOverlap()
	 * @see Window#setAllowReturnTransitionOverlap(boolean)
	 * @see #configureIncomingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T allowReturnTransitionOverlap(final boolean allow) {
<span class="fc" id="L561">		this.mAllowReturnTransitionOverlap = allow;</span>
<span class="fc" id="L562">		return (T) this;</span>
	}

	/**
	 * Returns boolean flag indicating whether return transition may overlap or not.
	 * &lt;p&gt;
	 * This method returns {@code true} if overlapping has not been specified, which is a default
	 * behaviour of {@link Window#getAllowReturnTransitionOverlap()}.
	 *
	 * @return {@code True} if overlapping of return transition is enabled, {@code false} otherwise.
	 */
	public boolean allowReturnTransitionOverlap() {
<span class="fc bfc" id="L574" title="All 4 branches covered.">		return mAllowReturnTransitionOverlap == null || mAllowReturnTransitionOverlap;</span>
	}

	/**
	 * Specifies enter transition for shared element to be attached to a window of an &lt;b&gt;incoming&lt;/b&gt;
	 * activity.
	 *
	 * @return This transition to allow methods chaining.
	 * @see #sharedElementEnterTransition()
	 * @see Window#setSharedElementEnterTransition(Transition)
	 * @see #inflateTransition(Context, int)
	 * @see #configureIncomingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T sharedElementEnterTransition(@Nullable final Transition transition) {
<span class="fc" id="L589">		this.mSpecifiedTransitions |= TRANSITION_SHARED_ELEMENT_ENTER;</span>
<span class="fc" id="L590">		this.mSharedElementEnterTransition = transition;</span>
<span class="fc" id="L591">		return (T) this;</span>
	}

	/**
	 * Returns shared element enter transition for the &lt;b&gt;incoming&lt;/b&gt; activity.
	 *
	 * @return Transition for shared element specified via {@link #sharedElementEnterTransition(Transition)}
	 * or {@code null} by default.
	 */
	@Nullable
	public Transition sharedElementEnterTransition() {
<span class="fc" id="L602">		return mSharedElementEnterTransition;</span>
	}

	/**
	 * Specifies reenter transition for shared element to be attached to a window of an &lt;b&gt;outgoing&lt;/b&gt;
	 * activity whenever {@link #start(Activity)} is invoked.
	 *
	 * @return This transition to allow methods chaining.
	 * @see #sharedElementReenterTransition()
	 * @see Window#setSharedElementReenterTransition(Transition)
	 * @see #inflateTransition(Context, int)
	 * @see #configureOutgoingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T sharedElementReenterTransition(@Nullable final Transition transition) {
<span class="fc" id="L617">		this.mSpecifiedTransitions |= TRANSITION_SHARED_ELEMENT_REENTER;</span>
<span class="fc" id="L618">		this.mSharedElementReenterTransition = transition;</span>
<span class="fc" id="L619">		return (T) this;</span>
	}

	/**
	 * Returns shared element reenter transition for the &lt;b&gt;outgoing&lt;/b&gt; activity.
	 *
	 * @return Transition for shared element specified via {@link #sharedElementReenterTransition(Transition)}
	 * or {@code null} by default.
	 */
	@Nullable
	public Transition sharedElementReenterTransition() {
<span class="fc" id="L630">		return mSharedElementReenterTransition;</span>
	}

	/**
	 * Specifies return transition for shared element to be attached to a window of an &lt;b&gt;incoming&lt;/b&gt;
	 * activity.
	 *
	 * @return This transition to allow methods chaining.
	 * @see #sharedElementReturnTransition()
	 * @see Window#setSharedElementReturnTransition(Transition)
	 * @see #inflateTransition(Context, int)
	 * @see #configureIncomingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T sharedElementReturnTransition(@Nullable final Transition transition) {
<span class="fc" id="L645">		this.mSpecifiedTransitions |= TRANSITION_SHARED_ELEMENT_RETURN;</span>
<span class="fc" id="L646">		this.mSharedElementReturnTransition = transition;</span>
<span class="fc" id="L647">		return (T) this;</span>
	}

	/**
	 * Returns shared element return transition for the &lt;b&gt;incoming&lt;/b&gt; activity.
	 *
	 * @return Transition for shared element specified via {@link #sharedElementReturnTransition(Transition)}
	 * or {@code null} by default.
	 */
	@Nullable
	public Transition sharedElementReturnTransition() {
<span class="fc" id="L658">		return mSharedElementReturnTransition;</span>
	}

	/**
	 * Specifies exit transition for shared element to be attached to a window of an &lt;b&gt;outgoing&lt;/b&gt;
	 * activity whenever {@link #start(Activity)} is invoked.
	 *
	 * @return This transition to allow methods chaining.
	 * @see #sharedElementExitTransition()
	 * @see Window#setSharedElementExitTransition(Transition)
	 * @see #inflateTransition(Context, int)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T sharedElementExitTransition(@Nullable final Transition transition) {
<span class="fc" id="L672">		this.mSpecifiedTransitions |= TRANSITION_SHARED_ELEMENT_EXIT;</span>
<span class="fc" id="L673">		this.mSharedElementExitTransition = transition;</span>
<span class="fc" id="L674">		return (T) this;</span>
	}

	/**
	 * Returns shared element exit transition for the &lt;b&gt;outgoing&lt;/b&gt; activity.
	 *
	 * @return Transition for shared element specified via {@link #sharedElementExitTransition(Transition)}
	 * or {@code null} by default.
	 */
	@Nullable
	public Transition sharedElementExitTransition() {
<span class="fc" id="L685">		return mSharedElementExitTransition;</span>
	}

	/**
	 * Specifies a boolean flag to be set to a window of an &lt;b&gt;incoming&lt;/b&gt; or &lt;b&gt;outgoing&lt;/b&gt; activity
	 * in order to indicate whether shared elements should use overlay or not.
	 * &lt;p&gt;
	 * Default value: &lt;b&gt;{@code unspecified}&lt;/b&gt;
	 *
	 * @return This transition to allow methods chaining.
	 * @see #sharedElementsUseOverlay()
	 * @see Window#setSharedElementsUseOverlay(boolean)
	 * @see #configureIncomingTransitions(Activity)
	 * @see #configureOutgoingTransitions(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T sharedElementsUseOverlay(final boolean useOverlay) {
<span class="fc" id="L702">		this.mSharedElementUseOverlay = useOverlay;</span>
<span class="fc" id="L703">		return (T) this;</span>
	}

	/**
	 * Returns boolean flag indicating whether shared elements should use overlay or not.
	 * &lt;p&gt;
	 * This method returns {@code true} if usage of overlay has not been specified, which is a default
	 * behaviour of {@link Window#getSharedElementsUseOverlay()}.
	 *
	 * @return {@code True} if shared elements will use overlay, {@code false} otherwise.
	 * @see #sharedElementsUseOverlay(boolean)
	 */
	public boolean sharedElementsUseOverlay() {
<span class="fc bfc" id="L716" title="All 4 branches covered.">		return mSharedElementUseOverlay == null || mSharedElementUseOverlay;</span>
	}

	/**
	 * Inflates a new instance of Transition from the specified &lt;var&gt;resource&lt;/var&gt;.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that for pre {@link Build.VERSION_CODES#LOLLIPOP LOLLIPOP} Android
	 * versions this method does nothing and returns {@code null}.
	 *
	 * @param context  Context used to inflate the desired transition.
	 * @param resource Resource id of the desired transition to inflate.
	 * @return Inflated transition.
	 * @see #inflateTransitionManager(Context, int, ViewGroup)
	 */
	@Nullable
	@SuppressLint(&quot;NewApi&quot;)
	public Transition inflateTransition(@NonNull final Context context, final int resource) {
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">		if (MATERIAL_SUPPORT) {</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">			if (mTransitionInflater == null) {</span>
<span class="fc" id="L735">				this.mTransitionInflater = TransitionInflater.from(context);</span>
			}
<span class="fc" id="L737">			return mTransitionInflater.inflateTransition(resource);</span>
		}
<span class="nc" id="L739">		return null;</span>
	}

	/**
	 * Inflates a new instance of TransitionManager from the specified &lt;var&gt;resource&lt;/var&gt;.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that for pre {@link Build.VERSION_CODES#LOLLIPOP LOLLIPOP} Android
	 * versions this method does nothing and returns {@code null}.
	 *
	 * @param context   Context used to inflate the desired transition.
	 * @param resource  Resource id of the desired transition manager to inflater.
	 * @param sceneRoot Root view for the scene with which will the manager operate.
	 * @return Inflated transition manager.
	 * @see #inflateTransition(Context, int)
	 */
	@Nullable
	@SuppressLint(&quot;NewApi&quot;)
	public TransitionManager inflateTransitionManager(@NonNull final Context context, final int resource, @NonNull final ViewGroup sceneRoot) {
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">		if (MATERIAL_SUPPORT) {</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">			if (mTransitionInflater == null) {</span>
<span class="fc" id="L759">				this.mTransitionInflater = TransitionInflater.from(context);</span>
			}
<span class="fc" id="L761">			return mTransitionInflater.inflateTransitionManager(resource, sceneRoot);</span>
		}
<span class="nc" id="L763">		return null;</span>
	}

	/**
	 * Bulk method for adding shared element pairs into this navigational transition.
	 *
	 * @param elements The desired shared elements pairs.
	 * @return This transition to allow methods chaining.
	 * @see #sharedElement(View, String)
	 */
	@SafeVarargs
	@SuppressWarnings(&quot;unchecked&quot;)
	public final T sharedElements(@NonNull final Pair&lt;View, String&gt;... elements) {
<span class="fc bfc" id="L776" title="All 2 branches covered.">		if (mSharedElements == null) {</span>
<span class="fc" id="L777">			this.mSharedElements = new ArrayList&lt;&gt;(1);</span>
		}
<span class="fc" id="L779">		mSharedElements.addAll(Arrays.asList(elements));</span>
<span class="fc" id="L780">		return (T) this;</span>
	}

	/**
	 * Adds shared element that should be transferred to the transitioning (called) activity via
	 * {@link ActivityOptions} as Bundle.
	 * &lt;p&gt;
	 * All shared elements and their names added into this navigational transition will be bundled
	 * from ActivityOptions created via {@link #makeSceneTransitionAnimation(Activity)} and transferred
	 * to the called activity whenever {@link #start(Activity)} is called.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that each shared element must have a unique name.
	 *
	 * @param element     The view to be shared via transition.
	 * @param elementName The name of the shared element.
	 * @return This transition to allow methods chaining.
	 * @see #sharedElements(Pair[])
	 * @see #makeSceneTransitionAnimation(Activity)
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public T sharedElement(@NonNull final View element, @NonNull final String elementName) {
<span class="fc bfc" id="L801" title="All 2 branches covered.">		if (mSharedElements == null) {</span>
<span class="fc" id="L802">			this.mSharedElements = new ArrayList&lt;&gt;(1);</span>
		}
<span class="fc" id="L804">		mSharedElements.add(new Pair&lt;&gt;(element, elementName));</span>
<span class="fc" id="L805">		return (T) this;</span>
	}

	/**
	 * Returns a list of all shared elements specified for this navigational transition.
	 *
	 * @return List of shared elements or {@code null} if there are no shared elements specified.
	 * @see #sharedElements(Pair[])
	 * @see #sharedElement(View, String)
	 * @see #singleSharedElement()
	 */
	@Nullable
	public List&lt;Pair&lt;View, String&gt;&gt; sharedElements() {
<span class="fc" id="L818">		return mSharedElements;</span>
	}

	/**
	 * Returns the single shared element at the {@code 0} position among the current shared elements.
	 * &lt;p&gt;
	 * This method may be used to obtain a single shared element when there is specified only one for
	 * this navigational transition.
	 *
	 * @return Single shared element or {@code null} if there are no shared elements specified.
	 * @see #sharedElements()
	 * @see #sharedElement(View, String)
	 */
	@Nullable
	public Pair&lt;View, String&gt; singleSharedElement() {
<span class="fc bfc" id="L833" title="All 4 branches covered.">		return mSharedElements == null || mSharedElements.isEmpty() ? null : mSharedElements.get(0);</span>
	}

	/**
	 * Starts this navigational transition using the given &lt;var&gt;caller&lt;/var&gt; activity with transitions
	 * and shared elements that are configured for the activity via {@link #configureOutgoingTransitions(Activity)}.
	 *
	 * @param caller The activity that will be used to create and start an Intent created via
	 *               {@link #createIntent(Activity)}.
	 */
	public void start(@NonNull final Activity caller) {
<span class="fc" id="L844">		configureOutgoingTransitions(caller);</span>
<span class="fc" id="L845">		onStart(caller);</span>
<span class="fc" id="L846">	}</span>

	/**
	 * Invoked whenever {@link #start(Activity)} is called.
	 * &lt;p&gt;
	 * Default implementation starts an Intent created via {@link #createIntent(Activity)} using
	 * the given caller activity via {@link Activity#startActivity(Intent)} for the pre LOLLIPOP
	 * Android versions and for the post LOLLIPOP via {@link Activity#startActivity(Intent, Bundle)}
	 * where will be passed Bundle created from {@link ActivityOptions} that has been requested via
	 * {@link #makeSceneTransitionAnimation(Activity)}.
	 * &lt;p&gt;
	 * If there was specified some {@link #requestCode()} the intent will be started via
	 * {@link Activity#startActivityForResult(Intent, int)} for the pre LOLLIPOP Android versions
	 * and for the post LOLLIPOP via {@link Activity#startActivityForResult(Intent, int, Bundle)}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that the specified caller activity has already attached transitions to its
	 * window, that has been specified for this navigational transition via one of {@code set...Transition(...)}
	 * methods.
	 *
	 * @param caller The caller activity that requested start of this navigational transition.
	 * @see #onFinish(Activity)
	 */
	@SuppressLint(&quot;NewApi&quot;)
	@SuppressWarnings(&quot;ConstantConditions&quot;)
	protected void onStart(@NonNull final Activity caller) {
<span class="fc" id="L871">		final Intent intent = createIntent(caller);</span>
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">		if (MATERIAL_SUPPORT) {</span>
<span class="fc" id="L873">			final Bundle options = makeSceneTransitionAnimation(caller).toBundle();</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">			if (mRequestCode == RC_NONE) caller.startActivity(intent, options);</span>
<span class="fc" id="L875">			else caller.startActivityForResult(intent, mRequestCode, options);</span>
<span class="fc" id="L876">		} else {</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">			if (mRequestCode == RC_NONE) caller.startActivity(intent);</span>
<span class="nc" id="L878">			else caller.startActivityForResult(intent, mRequestCode);</span>
		}
<span class="fc" id="L880">	}</span>

	/**
	 * Like {@link #finishCaller(Activity)} but this will postpone the finishing by the requested
	 * &lt;var&gt;delay&lt;/var&gt;.
	 *
	 * @param caller The caller activity to finish.
	 * @param delay  The desired delay after which to finish the caller activity.
	 */
	protected void finishCallerDelayed(@NonNull final Activity caller, @IntRange(from = 0) final long delay) {
<span class="fc" id="L890">		final View decorView = caller.getWindow().getDecorView();</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">		if (decorView != null) decorView.postDelayed(new Runnable() {</span>

			/**
			 */
			@Override
			public void run() {
<span class="pc bpc" id="L897" title="1 of 4 branches missed.">				if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1 &amp;&amp; caller.isDestroyed()) {</span>
<span class="fc" id="L898">					return;</span>
				}
<span class="fc bfc" id="L900" title="All 2 branches covered.">				if (caller.isFinishing()) {</span>
<span class="fc" id="L901">					return;</span>
				}
<span class="fc" id="L903">				onFinishCaller(caller);</span>
<span class="fc" id="L904">			}</span>
		}, delay);
<span class="fc" id="L906">	}</span>

	/**
	 * Finishes the specified &lt;var&gt;caller&lt;/var&gt; activity either via {@link Activity#finishAfterTransition()}
	 * or via {@link Activity#finish()} depending on the current API capabilities.
	 *
	 * @param caller The caller activity to finish.
	 */
	protected void finishCaller(@NonNull final Activity caller) {
<span class="fc" id="L915">		onFinishCaller(caller);</span>
<span class="fc" id="L916">	}</span>

	/**
	 * Invoked whenever {@link #finishCaller(Activity)} or {@link #finishCallerDelayed(Activity, long)}
	 * is called.
	 * &lt;p&gt;
	 * Default implementation finishes the caller activity either via {@link Activity#finishAfterTransition()}
	 * or via {@link Activity#finish()} depending on the current API capabilities.
	 *
	 * @param caller The caller activity to finish.
	 */
	@SuppressLint(&quot;NewApi&quot;)
	protected void onFinishCaller(@NonNull final Activity caller) {
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">		if (MATERIAL_SUPPORT) caller.finishAfterTransition();</span>
<span class="nc" id="L930">		else caller.finish();</span>
<span class="fc" id="L931">	}</span>

	/**
	 * &lt;b&gt;This method has been deprecated and will be removed in the next release.&lt;/b&gt;
	 * &lt;p&gt;
	 * Specifies a boolean flags for a window of the specified &lt;var&gt;activity&lt;/var&gt; determining whether
	 * an enter or return transition can overlap or not based on the requested values for this
	 * navigational transition.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that for pre {@link Build.VERSION_CODES#LOLLIPOP LOLLIPOP} Android
	 * versions this method does nothing.
	 *
	 * @param activity The activity for which window to specify whether an enter or return transition
	 *                 can overlap or not.
	 * @see Window#setAllowEnterTransitionOverlap(boolean)
	 * @see Window#setAllowReturnTransitionOverlap(boolean)
	 * @deprecated Use {@link #configureIncomingTransitions(Activity)} instead.
	 */
	@Deprecated
	public void configureTransitionsOverlapping(@NonNull final Activity activity) {
<span class="nc bnc" id="L951" title="All 2 branches missed.">		if (MATERIAL_SUPPORT) {</span>
<span class="nc" id="L952">			final Window window = activity.getWindow();</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">			if (mAllowEnterTransitionOverlap != null)</span>
<span class="nc" id="L954">				window.setAllowEnterTransitionOverlap(mAllowEnterTransitionOverlap);</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">			if (mAllowReturnTransitionOverlap != null)</span>
<span class="nc" id="L956">				window.setAllowReturnTransitionOverlap(mAllowReturnTransitionOverlap);</span>
		}
<span class="nc" id="L958">	}</span>

	/**
	 * This method groups calls to {@link #configureIncomingTransitions(Activity)} and
	 * {@link #configureOutgoingTransitions(Activity)} into one call.
	 *
	 * @param activity The activity of which window transitions to configure.
	 */
	public void configureTransitions(@NonNull final Activity activity) {
<span class="fc" id="L967">		configureIncomingTransitions(activity);</span>
<span class="fc" id="L968">		configureOutgoingTransitions(activity);</span>
<span class="fc" id="L969">	}</span>

	/**
	 * Performs configuration of the given &lt;var&gt;activity's&lt;/var&gt; window by attaching to it &lt;b&gt;enter&lt;/b&gt;
	 * and &lt;b&gt;return&lt;/b&gt; transitions (those for shared elements including) specified for this navigational
	 * transition. Also the configuration related to transitions overlapping will be performed here.
	 * &lt;p&gt;
	 * This method should be called from {@link Activity#onCreate(Bundle)} by the activity to which
	 * is the calling activity transitioning. See also {@link #configureOutgoingTransitions(Activity)}.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that for pre {@link Build.VERSION_CODES#LOLLIPOP LOLLIPOP} Android  versions this
	 * method does nothing.
	 *
	 * @param activity The activity of which window transitions to configure.
	 * @see Window#setEnterTransition(Transition)
	 * @see Window#setReturnTransition(Transition)
	 * @see Window#setSharedElementEnterTransition(Transition)
	 * @see Window#setSharedElementReturnTransition(Transition)
	 * @see Window#setAllowEnterTransitionOverlap(boolean)
	 * @see Window#setAllowReturnTransitionOverlap(boolean)
	 */
	public void configureIncomingTransitions(@NonNull final Activity activity) {
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">		if (MATERIAL_SUPPORT) {</span>
<span class="fc" id="L992">			final Window window = activity.getWindow();</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">			if ((mSpecifiedTransitions &amp; TRANSITION_ENTER) != 0) {</span>
<span class="fc" id="L994">				window.setEnterTransition(mEnterTransition);</span>
			}
<span class="fc bfc" id="L996" title="All 2 branches covered.">			if ((mSpecifiedTransitions &amp; TRANSITION_RETURN) != 0) {</span>
<span class="fc" id="L997">				window.setReturnTransition(mReturnTransition);</span>
			}
<span class="fc bfc" id="L999" title="All 2 branches covered.">			if ((mSpecifiedTransitions &amp; TRANSITION_SHARED_ELEMENT_ENTER) != 0) {</span>
<span class="fc" id="L1000">				window.setSharedElementEnterTransition(mSharedElementEnterTransition);</span>
			}
<span class="fc bfc" id="L1002" title="All 2 branches covered.">			if ((mSpecifiedTransitions &amp; TRANSITION_SHARED_ELEMENT_RETURN) != 0) {</span>
<span class="fc" id="L1003">				window.setSharedElementReturnTransition(mSharedElementReturnTransition);</span>
			}
<span class="fc bfc" id="L1005" title="All 2 branches covered.">			if (mAllowEnterTransitionOverlap != null) {</span>
<span class="fc" id="L1006">				window.setAllowEnterTransitionOverlap(mAllowEnterTransitionOverlap);</span>
			}
<span class="fc bfc" id="L1008" title="All 2 branches covered.">			if (mAllowReturnTransitionOverlap != null) {</span>
<span class="fc" id="L1009">				window.setAllowReturnTransitionOverlap(mAllowReturnTransitionOverlap);</span>
			}
<span class="fc bfc" id="L1011" title="All 2 branches covered.">			if (mSharedElementUseOverlay != null) {</span>
<span class="fc" id="L1012">				window.setSharedElementsUseOverlay(mSharedElementUseOverlay);</span>
			}
		}
<span class="fc" id="L1015">	}</span>

	/**
	 * Performs configuration of the given &lt;var&gt;activity's&lt;/var&gt; window by attaching to it &lt;b&gt;reenter&lt;/b&gt;
	 * and &lt;b&gt;exit&lt;/b&gt; transitions (those for shared elements including) specified for this navigational
	 * transition.
	 * &lt;p&gt;
	 * This method is by default invoked whenever {@link #start(Activity)} is called for this
	 * navigational transition. Its counterpart, {@link #configureIncomingTransitions(Activity)},
	 * should be called by the activity to which is the calling activity transitioning.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that for pre {@link Build.VERSION_CODES#LOLLIPOP LOLLIPOP} Android  versions this
	 * method does nothing.
	 *
	 * @param activity The activity of which window transitions to configure.
	 * @see Window#setReenterTransition(Transition)
	 * @see Window#setExitTransition(Transition)
	 * @see Window#setSharedElementReenterTransition(Transition)
	 * @see Window#setSharedElementExitTransition(Transition)
	 */
	public void configureOutgoingTransitions(@NonNull final Activity activity) {
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">		if (MATERIAL_SUPPORT) {</span>
<span class="fc" id="L1037">			final Window window = activity.getWindow();</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">			if ((mSpecifiedTransitions &amp; TRANSITION_REENTER) != 0) {</span>
<span class="fc" id="L1039">				window.setReenterTransition(mReenterTransition);</span>
			}
<span class="fc bfc" id="L1041" title="All 2 branches covered.">			if ((mSpecifiedTransitions &amp; TRANSITION_EXIT) != 0) {</span>
<span class="fc" id="L1042">				window.setExitTransition(mExitTransition);</span>
			}
<span class="fc bfc" id="L1044" title="All 2 branches covered.">			if ((mSpecifiedTransitions &amp; TRANSITION_SHARED_ELEMENT_REENTER) != 0) {</span>
<span class="fc" id="L1045">				window.setSharedElementReenterTransition(mSharedElementReenterTransition);</span>
			}
<span class="fc bfc" id="L1047" title="All 2 branches covered.">			if ((mSpecifiedTransitions &amp; TRANSITION_SHARED_ELEMENT_EXIT) != 0) {</span>
<span class="fc" id="L1048">				window.setSharedElementExitTransition(mSharedElementExitTransition);</span>
			}
<span class="fc bfc" id="L1050" title="All 2 branches covered.">			if (mSharedElementUseOverlay != null) {</span>
<span class="fc" id="L1051">				window.setSharedElementsUseOverlay(mSharedElementUseOverlay);</span>
			}
		}
<span class="fc" id="L1054">	}</span>

	/**
	 * Creates a new instance of ActivityOptions for the specified &lt;var&gt;caller&lt;/var&gt; activity.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that for pre {@link Build.VERSION_CODES#LOLLIPOP LOLLIPOP} Android
	 * versions this method does nothing and returns {@code null}.
	 *
	 * @param caller The activity for which to create the ActivityOptions.
	 * @return Activity options with or without attached shared elements that has been added into
	 * this navigational transition (if any).
	 */
	@Nullable
	@SuppressLint(&quot;NewApi&quot;)
	@SuppressWarnings(&quot;unchecked&quot;)
	public ActivityOptions makeSceneTransitionAnimation(@NonNull final Activity caller) {
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">		if (MATERIAL_SUPPORT) {</span>
<span class="fc bfc" id="L1071" title="All 4 branches covered.">			if (mSharedElements != null &amp;&amp; !mSharedElements.isEmpty()) {</span>
<span class="fc" id="L1072">				final Pair&lt;View, String&gt;[] pairs = new Pair[mSharedElements.size()];</span>
<span class="fc" id="L1073">				mSharedElements.toArray(pairs);</span>
<span class="fc" id="L1074">				return ActivityOptions.makeSceneTransitionAnimation(caller, pairs);</span>
			}
<span class="fc" id="L1076">			return ActivityOptions.makeSceneTransitionAnimation(caller);</span>
		}
<span class="nc" id="L1078">		return null;</span>
	}

	/**
	 * Creates an intent that can be used to start activity for which is this transition created.
	 *
	 * @param caller Activity to be used as context when creating the requested intent.
	 * @return New Intent or {@code null} it this navigational transition has no class of transition
	 * activity specified.
	 */
	@NonNull
	public Intent createIntent(@NonNull final Activity caller) {
<span class="fc bfc" id="L1090" title="All 2 branches covered.">		if (mClassOfTransitionActivity == null) {</span>
<span class="fc" id="L1091">			throw new UnsupportedOperationException(</span>
<span class="fc" id="L1092">					&quot;Navigational transition(&quot; + getClass().getSimpleName() + &quot;) does not have any class of intended activity specified.&quot;</span>
			);
		}
<span class="fc" id="L1095">		final Intent intent = new Intent(caller, mClassOfTransitionActivity);</span>
<span class="fc bfc" id="L1096" title="All 2 branches covered.">		if (mIntentExtras != null) {</span>
<span class="fc" id="L1097">			intent.putExtras(mIntentExtras);</span>
		}
<span class="fc" id="L1099">		return intent;</span>
	}

	/**
	 * Finishes the given &lt;var&gt;caller&lt;/var&gt; activity in order to run its exit transitions.
	 *
	 * @param caller The activity that should be finished and of which exit transitions should be started.
	 * @see #start(Activity)
	 */
	public void finish(@NonNull final Activity caller) {
<span class="fc" id="L1109">		onFinish(caller);</span>
<span class="fc" id="L1110">	}</span>

	/**
	 * Invoked whenever {@link #finish(Activity)} is called.
	 * &lt;p&gt;
	 * Default implementation finishes the given caller activity for the pre LOLLIPOP Android versions
	 * via {@link Activity#finish()} and for the post LOLLIPOP via {@link Activity#finishAfterTransition()}.
	 * &lt;p&gt;
	 * Derived classes can override this method in order to run custom window transitions for the
	 * pre LOLLIPOP Android versions via {@link Activity#overridePendingTransition(int, int)}.
	 *
	 * @param caller The activity that requested its finish via this navigational transition.
	 * @see #onStart(Activity)
	 */
	@SuppressLint(&quot;NewApi&quot;)
	protected void onFinish(@NonNull final Activity caller) {
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">		if (MATERIAL_SUPPORT) caller.finishAfterTransition();</span>
<span class="nc" id="L1127">		else caller.finish();</span>
<span class="fc" id="L1128">	}</span>

	/*
	 * Inner classes ===============================================================================
	 */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.2</div></body></html>